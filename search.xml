<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>bootstrap</title>
      <link href="/2021/06/23/bootstrap/"/>
      <url>/2021/06/23/bootstrap/</url>
      
        <content type="html"><![CDATA[<ul><li>Bootstrap<ul><li>弹出插件SweetAlert：<a href="http://mishengqiang.com/sweetalert/">http://mishengqiang.com/sweetalert/</a></li></ul></li></ul><ol><li><p>Bootstrap是什么？</p><pre><code> twitter公司开源的一个前端开发框架。（一坨HTML、CSS和JS的代码）</code></pre><ol start="2"><li><p>Bootstrap的版本<br> 3.3.版本</p></li><li><p>Bootstrap的使用</p><h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><ol><li><p>Bootstrap内置的： <a href="https://v3.bootcss.com/components/">https://v3.bootcss.com/components/</a></p><p>​        font-awesome图标：<a href="http://www.fontawesome.com.cn/">http://www.fontawesome.com.cn/</a></p><p>​        阿里图标：        <a href="http://iconfont.cn/">http://iconfont.cn/</a></p></li><li><p>面板</p><ol><li>jS插件</li></ol></li><li><p>下载<br> <a href="https://v3.bootcss.com/">https://v3.bootcss.com/</a></p></li><li><p>导入<br> link标签导入 bootstrap.css或者bootstrap.min.css</p></li></ol></li><li><p>常用样式类</p><ol><li>容器<ol><li>container</li><li>container-fluid</li></ol></li><li>栅格系统<br>  把一行均分成最多12列<br>  可以设置标签占多少列<ol><li>row表示一行</li><li>col-xx-**表示一列<br>   xx: 表示样式适用的屏幕尺寸<pre><code> - xs  手机   - sm  平板     - md  桌面显示器       - lg  超大屏幕     **：表示占多少份         - 取值范围： 1~12</code></pre></li><li>col-xx-offset-**:<br>   表示左侧空几份！</li><li>列支持再嵌套（再写一行，分成12份）</li><li>列排序<ol><li>col-xx-push-*  –&gt; 往右推<ol start="2"><li>col-xx-pull-*  –&gt; 往左拉</li></ol></li></ol></li></ol></li><li>布局样式</li><li>表格</li><li>表单</li><li>按钮</li><li>图片</li><li>辅助类<ol><li>文本颜色</li><li>背景颜色</li><li>快速浮动</li><li>清除浮动</li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> boostrap插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端jQuery</title>
      <link href="/2021/06/19/%E5%89%8D%E7%AB%AFjQuery/"/>
      <url>/2021/06/19/%E5%89%8D%E7%AB%AFjQuery/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h2><ol><li>jQuery是一个轻量级的、兼容多浏览器的JavaScript库。</li><li>jQuery使用户能够更方便地处理HTML Document、Events、实现动画效果、方便地进行Ajax交互，能够极大地简化JavaScript编程。它的宗旨就是：“Write less, do more.“</li></ol><h2 id="jQuery的优势"><a href="#jQuery的优势" class="headerlink" title="jQuery的优势"></a>jQuery的优势</h2><ol><li>一款轻量级的JS框架。jQuery核心js文件才几十kb，不会影响页面加载速度。</li><li>丰富的DOM选择器,jQuery的选择器用起来很方便，比如要找到某个DOM对象的相邻元素，JS可能要写好几行代码，而jQuery一行代码就搞定了，再比如要将一个表格的隔行变色，jQuery也是一行代码搞定。</li><li>链式表达式。jQuery的链式操作可以把多个操作写在一行代码里，更加简洁。</li><li>事件、样式、动画支持。jQuery还简化了js操作css的代码，并且代码的可读性也比js要强。</li><li>Ajax操作支持。jQuery简化了AJAX操作，后端只需返回一个JSON格式的字符串就能完成与前端的通信。</li><li>跨浏览器兼容。jQuery基本兼容了现在主流的浏览器，不用再为浏览器的兼容问题而伤透脑筋。</li><li>插件扩展开发。jQuery有着丰富的第三方的插件，例如：树形菜单、日期控件、图片切换插件、弹出窗口等等基本前端页面上的组件都有对应插件，并且用jQuery插件做出来的效果很炫，并且可以根据自己需要去改写和封装插件，简单实用。</li></ol><h2 id="jQuery内容："><a href="#jQuery内容：" class="headerlink" title="jQuery内容："></a>jQuery内容：</h2><ol><li>选择器</li><li>筛选器</li><li>样式操作</li><li>文本操作</li><li>属性操作</li><li>文档处理</li><li>事件</li><li>动画效果</li><li>插件</li><li>each、data、Ajax</li></ol><p>下载链接：<a href="https://jquery.com/">jQuery官网</a></p><p>中文文档：<a href="http://jquery.cuishifeng.cn/">jQuery AP中文文档</a></p><h2 id="jQuery版本"><a href="#jQuery版本" class="headerlink" title="jQuery版本"></a>jQuery版本</h2><ul><li>1.x：兼容IE678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</li><li>2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</li><li>3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的jQuery插件不支持3.x版。目前该版本是官方主要更新维护的版本。</li></ul><p><em>维护IE678是一件让人头疼的事情，一般我们都会额外加载一个CSS和JS单独处理。值得庆幸的是使用这些浏览器的人也逐步减少，PC端用户已经逐步被移动端用户所取代，如果没有特殊要求的话，一般都会选择放弃对678的支持。</em></p><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><p><strong>jQuery对象</strong>就是通过jQuery包装DOM对象后产生的对象。<strong>jQuery对象</strong>是 jQuery独有的。如果一个对象是 <strong>jQuery对象</strong>，那么它就可以使用<strong>jQuery</strong>里的方法：例如$(“#i1”).html()。</p><p><code>$(&quot;#i1&quot;).html()</code>的意思是：获取id值为 <code>i1</code>的元素的html代码。其中 <code>html()</code>是jQuery里的方法。</p><p>相当于： <code>document.getElementById(&quot;i1&quot;).innerHTML;</code></p><p>虽然 <code>jQuery对象</code>是包装 <code>DOM对象</code>后产生的，但是 <code>jQuery对象</code>无法使用 <code>DOM对象</code>的任何方法，同理 <code>DOM对象</code>也没不能使用 <code>jQuery</code>里的方法。</p><p>一个约定，我们在声明一个jQuery对象变量的时候在变量名前面加上$：</p><pre><code>var $variable = jQuery对像var variable = DOM对象$variable[0]//jQuery对象转成DOM对象</code></pre><p>拿上面那个例子举例，jQuery对象和DOM对象的使用：</p><pre><code>$(&quot;#i1&quot;).html();//jQuery对象可以使用jQuery的方法$(&quot;#i1&quot;)[0].innerHTML;// DOM对象使用DOM的方法</code></pre><h2 id="jQuery基础语法"><a href="#jQuery基础语法" class="headerlink" title="jQuery基础语法"></a>jQuery基础语法</h2><pre><code>$(selector).action()</code></pre><h2 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><p><strong>id选择器：</strong></p><pre><code>$(&quot;#id&quot;)</code></pre><p><strong>标签选择器：</strong></p><pre><code>$(&quot;tagName&quot;)</code></pre><p><strong>class选择器：</strong></p><pre><code>$(&quot;.className&quot;)</code></pre><p><strong>配合使用：</strong></p><pre><code>$(&quot;div.c1&quot;)  // 找到有c1 class类的div标签</code></pre><p><strong>所有元素选择器：</strong></p><pre><code>$(&quot;*&quot;)</code></pre><p><strong>组合选择器：</strong></p><pre><code>$(&quot;#id, .className, tagName&quot;)</code></pre><h3 id="层级选择器："><a href="#层级选择器：" class="headerlink" title="层级选择器："></a><strong>层级选择器：</strong></h3><p><em>x和y可以为任意选择器</em></p><pre><code>$(&quot;x y&quot;);// x的所有后代y（子子孙孙）$(&quot;x &gt; y&quot;);// x的所有儿子y（儿子）$(&quot;x + y&quot;)// 找到所有紧挨在x后面的y$(&quot;x ~ y&quot;)// x之后所有的兄弟y</code></pre><h3 id="基本筛选器："><a href="#基本筛选器：" class="headerlink" title="基本筛选器："></a><strong>基本筛选器：</strong></h3><pre><code>:first // 第一个:last // 最后一个:eq(index)// 索引等于index的那个元素:even // 匹配所有索引值为偶数的元素，从 0 开始计数:odd // 匹配所有索引值为奇数的元素，从 0 开始计数:gt(index)// 匹配所有大于给定索引值的元素:lt(index)// 匹配所有小于给定索引值的元素:not(元素选择器)// 移除所有满足not条件的标签:has(元素选择器)// 选取所有包含一个或多个标签在其内的标签(指的是从后代元素找)</code></pre><p><strong>例子：</strong></p><pre><code>$(&quot;div:has(h1)&quot;)// 找到所有后代中有h1标签的div标签$(&quot;div:has(.c1)&quot;)// 找到所有后代中有c1样式类的div标签$(&quot;li:not(.c1)&quot;)// 找到所有不包含c1样式类的li标签$(&quot;li:not(:has(a))&quot;)// 找到所有后代中不含a标签的li标签</code></pre><p>练习：</p><p>自定义模态框，使用jQuery实现弹出和隐藏功能。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;自定义模态框&lt;/title&gt;  &lt;style&gt;    .cover &#123;      position: fixed;      left: 0;      right: 0;      top: 0;      bottom: 0;      background-color: darkgrey;      z-index: 999;    &#125;    .modal &#123;      width: 600px;      height: 400px;      background-color: white;      position: fixed;      left: 50%;      top: 50%;      margin-left: -300px;      margin-top: -200px;      z-index: 1000;    &#125;    .hide &#123;      display: none;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;弹&quot; id=&quot;i0&quot;&gt;&lt;div class=&quot;cover hide&quot;&gt;&lt;/div&gt;&lt;div class=&quot;modal hide&quot;&gt;  &lt;label for=&quot;i1&quot;&gt;姓名&lt;/label&gt;  &lt;input id=&quot;i1&quot; type=&quot;text&quot;&gt;   &lt;label for=&quot;i2&quot;&gt;爱好&lt;/label&gt;  &lt;input id=&quot;i2&quot; type=&quot;text&quot;&gt;  &lt;input type=&quot;button&quot; id=&quot;i3&quot; value=&quot;关闭&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  var tButton = $(&quot;#i0&quot;)[0];  tButton.onclick=function () &#123;    var coverEle = $(&quot;.cover&quot;)[0];    var modalEle = $(&quot;.modal&quot;)[0];    $(coverEle).removeClass(&quot;hide&quot;);    $(modalEle).removeClass(&quot;hide&quot;);  &#125;;  var cButton = $(&quot;#i3&quot;)[0];  cButton.onclick=function () &#123;    var coverEle = $(&quot;.cover&quot;)[0];    var modalEle = $(&quot;.modal&quot;)[0];    $(coverEle).addClass(&quot;hide&quot;);    $(modalEle).addClass(&quot;hide&quot;);  &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a><strong>属性选择器：</strong></h3><pre><code>[attribute][attribute=value]// 属性等于[attribute!=value]// 属性不等于</code></pre><p><strong>例子：</strong></p><pre><code>// 示例&lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;password&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;$(&quot;input[type=&#39;checkbox&#39;]&quot;);// 取到checkbox类型的input标签$(&quot;input[type!=&#39;text&#39;]&quot;);// 取到类型不是text的input标签</code></pre><h3 id="表单筛选器："><a href="#表单筛选器：" class="headerlink" title="表单筛选器："></a><strong>表单筛选器</strong>：</h3><pre><code>:text:password:file:radio:checkbox:submit:reset:button</code></pre><p><strong>例子：</strong></p><pre><code>$(&quot;:checkbox&quot;)  // 找到所有的checkbox</code></pre><p>表单对象属性:</p><pre><code>:enabled:disabled:checked:selected</code></pre><p><strong>例子：</strong></p><p>找到可用的input标签</p><pre><code>&lt;form&gt;  &lt;input name=&quot;email&quot; disabled=&quot;disabled&quot; /&gt;  &lt;input name=&quot;id&quot; /&gt;&lt;/form&gt;$(&quot;input:enabled&quot;)  // 找到可用的input标签</code></pre><p> 找到被选中的option：</p><pre><code>&lt;select id=&quot;s1&quot;&gt;  &lt;option value=&quot;beijing&quot;&gt;北京市&lt;/option&gt;  &lt;option value=&quot;shanghai&quot;&gt;上海市&lt;/option&gt;  &lt;option selected value=&quot;guangzhou&quot;&gt;广州市&lt;/option&gt;  &lt;option value=&quot;shenzhen&quot;&gt;深圳市&lt;/option&gt;&lt;/select&gt;$(&quot;:selected&quot;)  // 找到所有被选中的option</code></pre><h2 id="筛选器方法"><a href="#筛选器方法" class="headerlink" title="筛选器方法"></a>筛选器方法</h2><p>下一个元素：</p><pre><code>$(&quot;#id&quot;).next()$(&quot;#id&quot;).nextAll()$(&quot;#id&quot;).nextUntil(&quot;#i2&quot;)</code></pre><p>上一个元素：</p><pre><code>$(&quot;#id&quot;).prev()$(&quot;#id&quot;).prevAll()$(&quot;#id&quot;).prevUntil(&quot;#i2&quot;)</code></pre><p>父亲元素：</p><pre><code>$(&quot;#id&quot;).parent()$(&quot;#id&quot;).parents()  // 查找当前元素的所有的父辈元素$(&quot;#id&quot;).parentsUntil() // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。</code></pre><p>儿子和兄弟元素：</p><pre><code>$(&quot;#id&quot;).children();// 儿子们$(&quot;#id&quot;).siblings();// 兄弟们</code></pre><p>查找</p><p>搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。</p><pre><code>$(&quot;div&quot;).find(&quot;p&quot;)</code></pre><p>等价于$(“div p”)</p><p>筛选</p><p>筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配的范围。用逗号分隔多个表达式。</p><pre><code>$(&quot;div&quot;).filter(&quot;.c1&quot;)  // 从结果集中过滤出有c1样式类的</code></pre><p>等价于 $(“div.c1”)</p><p>补充：</p><pre><code>.first() // 获取匹配的第一个元素.last() // 获取匹配的最后一个元素.not() // 从匹配元素的集合中删除与指定表达式匹配的元素.has() // 保留包含特定后代的元素，去掉那些不含有指定后代的元素。.eq() // 索引值等于指定值的元素</code></pre><p>示例：左侧菜单</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;左侧菜单示例&lt;/title&gt;  &lt;style&gt;    .left &#123;      position: fixed;      left: 0;      top: 0;      width: 20%;      height: 100%;      background-color: rgb(47, 53, 61);    &#125;    .right &#123;      width: 80%;      height: 100%;    &#125;    .menu &#123;      color: white;    &#125;    .title &#123;      text-align: center;      padding: 10px 15px;      border-bottom: 1px solid #23282e;    &#125;    .items &#123;      background-color: #181c20;    &#125;    .item &#123;      padding: 5px 10px;      border-bottom: 1px solid #23282e;    &#125;    .hide &#123;      display: none;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;left&quot;&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;div class=&quot;title&quot;&gt;菜单一&lt;/div&gt;    &lt;div class=&quot;items&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;title&quot;&gt;菜单二&lt;/div&gt;    &lt;div class=&quot;items hide&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;title&quot;&gt;菜单三&lt;/div&gt;    &lt;div class=&quot;items hide&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;.title&quot;).click(function ()&#123;  // jQuery绑定事件    // 隐藏所有class里有.items的标签    $(&quot;.items&quot;).addClass(&quot;hide&quot;);  //批量操作    $(this).next().removeClass(&quot;hide&quot;);  &#125;);&lt;/script&gt;</code></pre><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><p>样式类</p><pre><code>addClass();// 添加指定的CSS类名。removeClass();// 移除指定的CSS类名。hasClass();// 判断样式存不存在toggleClass();// 切换CSS类名，如果有就移除，如果没有就添加。</code></pre><p>示例：开关灯和模态框</p><p>CSS</p><pre><code>css(&quot;color&quot;,&quot;red&quot;)//DOM操作：tag.style.color=&quot;red&quot;</code></pre><p>示例：</p><pre><code>$(&quot;p&quot;).css(&quot;color&quot;, &quot;red&quot;); //将所有p标签的字体设置为红色</code></pre><h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><pre><code>offset()// 获取匹配元素在当前窗口的相对偏移或设置元素位置position()// 获取匹配元素相对父元素的偏移scrollTop()// 获取匹配元素相对滚动条顶部的偏移scrollLeft()// 获取匹配元素相对滚动条左侧的偏移</code></pre><p><code>.offset()</code>方法允许我们检索一个元素相对于文档（document）的当前位置。</p><p>和 <code>.position()</code>的差别在于： <code>.position()</code>是相对于相对于父级元素的位移。</p><h3 id="尺寸："><a href="#尺寸：" class="headerlink" title="尺寸："></a>尺寸：</h3><pre><code>height()width()innerHeight()innerWidth()outerHeight()outerWidth()</code></pre><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><p>HTML代码：</p><pre><code>html()// 取得第一个匹配元素的html内容html(val)// 设置所有匹配元素的html内容</code></pre><p>文本值：</p><pre><code>text()// 取得所有匹配元素的内容text(val)// 设置所有匹配元素的内容</code></pre><p>值：</p><pre><code>val()// 取得第一个匹配元素的当前值val(val)// 设置所有匹配元素的值val([val1, val2])// 设置多选的checkbox、多选select的值</code></pre><p>例如：</p><pre><code>&lt;input type=&quot;checkbox&quot; value=&quot;basketball&quot; name=&quot;hobby&quot;&gt;篮球&lt;input type=&quot;checkbox&quot; value=&quot;football&quot; name=&quot;hobby&quot;&gt;足球&lt;select multiple id=&quot;s1&quot;&gt;    &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;    &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;    &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;&lt;/select&gt;</code></pre><p>设置值：</p><pre><code>$(&quot;[name=&#39;hobby&#39;]&quot;).val([&#39;basketball&#39;, &#39;football&#39;]);$(&quot;#s1&quot;).val([&quot;1&quot;, &quot;2&quot;])</code></pre><p>示例：</p><p>获取被选中的checkbox或radio的值：</p><pre><code>&lt;label for=&quot;c1&quot;&gt;女&lt;/label&gt;&lt;input name=&quot;gender&quot; id=&quot;c1&quot; type=&quot;radio&quot; value=&quot;0&quot;&gt;&lt;label for=&quot;c2&quot;&gt;男&lt;/label&gt;&lt;input name=&quot;gender&quot; id=&quot;c2&quot; type=&quot;radio&quot; value=&quot;1&quot;&gt;</code></pre><p>可以使用：</p><pre><code>$(&quot;input[name=&#39;gender&#39;]:checked&quot;).val()</code></pre><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>用于ID等或自定义属性：</p><pre><code>attr(attrName)// 返回第一个匹配元素的属性值attr(attrName, attrValue)// 为所有匹配元素设置一个属性值attr(&#123;k1: v1, k2:v2&#125;)// 为所有匹配元素设置多个属性值removeAttr()// 从每一个匹配的元素中删除一个属性</code></pre><p>用于checkbox和radio</p><pre><code>prop() // 获取属性removeProp() // 移除属性</code></pre><p><strong>注意：</strong></p><p>在1.x及2.x版本的jQuery中使用attr对checkbox进行赋值操作时会出bug，在3.x版本的jQuery中则没有这个问题。为了兼容性，我们在处理checkbox和radio的时候尽量使用特定的prop()，不要使用attr(“checked”, “checked”)。</p><pre><code>&lt;input type=&quot;checkbox&quot; value=&quot;1&quot;&gt;&lt;input type=&quot;radio&quot; value=&quot;2&quot;&gt;&lt;script&gt;  $(&quot;:checkbox[value=&#39;1&#39;]&quot;).prop(&quot;checked&quot;, true);  $(&quot;:radio[value=&#39;2&#39;]&quot;).prop(&quot;checked&quot;, true);&lt;/script&gt;</code></pre><p><strong>prop和attr的区别：</strong></p><p>attr全称attribute(属性) </p><p>prop全称property(属性)</p><p>虽然都是属性，但他们所指的属性并不相同，attr所指的属性是HTML标签属性，而prop所指的是DOM对象属性，可以认为attr是显式的，而prop是隐式的。</p><p>举个例子：</p><pre><code>&lt;input type=&quot;checkbox&quot; id=&quot;i1&quot; value=&quot;1&quot;&gt;</code></pre><p>针对上面的代码，</p><pre><code>$(&quot;#i1&quot;).attr(&quot;checked&quot;)  // undefined$(&quot;#i1&quot;).prop(&quot;checked&quot;)  // false</code></pre><p>可以看到attr获取一个标签内没有的东西会得到undefined，而prop获取的是这个DOM对象的属性，因此checked为false。</p><p>如果换成下面的代码：</p><pre><code>&lt;input type=&quot;checkbox&quot; checked id=&quot;i1&quot; value=&quot;1&quot;&gt;</code></pre><p>再执行：</p><pre><code>$(&quot;#i1&quot;).attr(&quot;checked&quot;)   // checked$(&quot;#i1&quot;).prop(&quot;checked&quot;)  // true</code></pre><p>这已经可以证明attr的局限性，它的作用范围只限于HTML标签内的属性，而prop获取的是这个DOM对象的属性，选中返回true，没选中返回false。</p><p>接下来再看一下针对自定义属性，attr和prop又有什么区别：</p><pre><code>&lt;input type=&quot;checkbox&quot; checked id=&quot;i1&quot; value=&quot;1&quot; me=&quot;自定义属性&quot;&gt;</code></pre><p>执行以下代码：</p><pre><code>$(&quot;#i1&quot;).attr(&quot;me&quot;)   // &quot;自定义属性&quot;$(&quot;#i1&quot;).prop(&quot;me&quot;)  // undefined</code></pre><p>可以看到prop不支持获取标签的自定义属性。</p><p><strong>总结一下：</strong></p><ol><li>对于标签上有的能看到的属性和自定义属性都用attr</li><li>对于返回布尔值的比如checkbox、radio和option的是否被选中都用prop。</li></ol><p>练习题:   登录验证</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; id=&quot;d1&quot;&gt;    &lt;p&gt;        &lt;label&gt;用户名:            &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;i1&quot;&gt;            &lt;span&gt;&lt;/span&gt;        &lt;/label&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;密码:            &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;i2&quot;&gt;            &lt;span&gt;&lt;/span&gt;        &lt;/label&gt;    &lt;/p&gt;    &lt;button type=&quot;button&quot; id=&quot;b1&quot;&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    $(&quot;#b1&quot;).click(function () &#123;        var $inputEle = $(&quot;#d1 input&quot;);        for (var i = 0; i &lt; $inputEle.length; i++) &#123;            var tmp = $inputEle[i];            if ($(tmp).val().length === 0) &#123;                //trim 去空格 slice(0,1)去最后一个                console.log($(tmp).parent().text().trim().slice(0, -1));                var s = $(tmp).parent().text().trim().slice(0, -1)                $(tmp).next().text(s + &quot;不能为空&quot;).css(&quot;color&quot;, &quot;red&quot;)            &#125;        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>练习题：全选、反选、取消</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;序号&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;爱好&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;八戒&lt;/td&gt;        &lt;td&gt;吃饭&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;悟空&lt;/td&gt;        &lt;td&gt;打怪&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;唐僧&lt;/td&gt;        &lt;td&gt;念经&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;button id=&quot;b1&quot;&gt;全选&lt;/button&gt;&lt;button id=&quot;b2&quot;&gt;取消&lt;/button&gt;&lt;button id=&quot;b3&quot;&gt;反选&lt;/button&gt;&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    // 全选    $(&quot;#b1&quot;).click(function () &#123;        $(&quot;:checkbox&quot;).prop(&quot;checked&quot;, true);    &#125;);    //取消    $(&quot;#b2&quot;).click(function () &#123;        $(&quot;:checkbox&quot;).prop(&quot;checked&quot;, false);    &#125;);    // 反选    $(&quot;#b3&quot;).click(function () &#123;        //     第一种方法        //     var $check = $(&quot;:checkbox&quot;);        //     for (var i=0;i&lt;$check.length;i++)&#123;        //     var tmp = $check[i];        //     var s = $(tmp).prop(&quot;checked&quot;)        //     $(tmp).prop(&quot;checked&quot;, !s);        // &#125;         $(&quot;#b3&quot;).click(function () &#123;            $(&quot;:checkbox&quot;).each(function () &#123;            var check = $(this).prop(&quot;checked&quot;)            // if (check)&#123;            //     $(this).prop(&quot;checked&quot;,false)            // &#125;else &#123;            //     $(this).prop(&quot;checked&quot;,true)            // &#125;            $(this).prop(&quot;checked&quot;,!check)        &#125;)    &#125;);        //第二种方法        //找到所有被选中的        var $checked = $(&quot;input:checked&quot;);        //找到所有没有被选中的        var $unchecked = $(&quot;input:not(:checked)&quot;);        $checked.prop(&quot;checked&quot;, false);        $unchecked.prop(&quot;checked&quot;, true);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h3><p>添加到指定元素<strong>内部</strong>的后面</p><pre><code>$(A).append(B)// 把B追加到A$(A).appendTo(B)// 把A追加到B</code></pre><p>添加到指定元素<strong>内部</strong>的前面</p><pre><code>$(A).prepend(B)// 把B前置到A$(A).prependTo(B)// 把A前置到B</code></pre><p>添加到指定元素<strong>外部</strong>的后面</p><pre><code>$(A).after(B)// 把B放到A的后面$(A).insertAfter(B)// 把A放到B的后面</code></pre><p>添加到指定元素<strong>外部</strong>的前面</p><pre><code>$(A).before(B)// 把B放到A的前面$(A).insertBefore(B)// 把A放到B的前面</code></pre><p>移除和清空元素</p><pre><code>remove()// 从DOM中删除所有匹配的元素。empty()// 删除匹配的元素集合中所有的子节点。</code></pre><p>例子：</p><p>点击按钮在表格添加一行数据。</p><p>点击每一行的删除按钮删除当前行数据。</p><p>替换</p><pre><code>replaceWith()replaceAll()</code></pre><p>克隆</p><pre><code>clone()// 参数</code></pre><p>克隆示例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button class=&quot;btn&quot;&gt;屠龙宝刀,点击就送!&lt;/button&gt;&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    $(&quot;.btn&quot;).click(function () &#123;        // 自己复制自己, 然后把复制的结果添加到自己的后面        $(this).clone(true).insertAfter(this);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><pre><code>click(function()&#123;...&#125;)hover(function()&#123;...&#125;)blur(function()&#123;...&#125;)focus(function()&#123;...&#125;)change(function()&#123;...&#125;)keyup(function()&#123;...&#125;)</code></pre><ul><li>hover事件实例  hover购物</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        body&#123;            margin: 0;        &#125;        .menu&#123;            height: 50px;            width: 100%;            background-color: #0f0f0f;            color: darkgrey;        &#125;        .menu&gt;ul&#123;            list-style-type: none;            margin: 0;            padding: 0;        &#125;        .menu&gt;ul&gt;li&#123;            float: left;            line-height: 50px;            margin-right: 20px;            position: relative;        &#125;        .shop-cart&#123;            background-color: #00a9ff;            color: white;            height: 50px;            width: 100px;            position: absolute;            right: 0;            display: none;        &#125;        .hover&gt;.shop-cart&#123;            display: block;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;menu&quot;&gt;    &lt;ul&gt;        &lt;li&gt;登录&lt;/li&gt;        &lt;li&gt;注册&lt;/li&gt;        &lt;li class=&quot;cart&quot;&gt;购物车            &lt;div class=&quot;shop-cart&quot;&gt;                空空乳液~            &lt;/div&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    // $(&quot;.cart&quot;).hover(    //     function () &#123;    //         // 鼠标移进来    //         $(&quot;.shop-cart&quot;).css(&quot;display&quot;,&quot;block&quot;)    // &#125;,    //     function () &#123;    //         // 鼠标移出去    //         $(&quot;.shop-cart&quot;).css(&quot;display&quot;,&quot;none&quot;)    //     &#125;    // )    // $(&quot;.cart&quot;).hover(    //     function () &#123;    //         $(this).addClass(&quot;hover&quot;);    // &#125;,    //     function () &#123;    //         $(this).removeClass(&quot;hover&quot;)    //     &#125;    // )    $(&quot;.menu&quot;).on(&quot;mouseenter&quot;,&quot;.cart&quot;, function () &#123;        // 绑定鼠标进入事件        $(this).addClass(&quot;hover&quot;);    &#125;);    $(&quot;.menu&quot;).on(&quot;mouseleave&quot;, &quot;.cart&quot;, function () &#123;        // 绑定鼠标移出事件        $(this).removeClass(&quot;hover&quot;);    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>blur事件实例  input实时校验</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;i1&quot;&gt;&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    // input框失去焦点就触发    // $(&quot;#i1&quot;).blur(function () &#123;    //     var value = $(this).val();    //     console.log(value)    // &#125;)    // 只要input框的值发生变化就触发    $(&quot;#i1&quot;).on(&quot;input&quot;,function () &#123;            var value = $(this).val();            console.log(value)    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>keydown 和 keyup 事件实例  shift批量操作</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;#&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;Egon&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;Alex&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;Yuan&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;EvaJ&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;Gold&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;input type=&quot;button&quot; id=&quot;b1&quot; value=&quot;全选&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;b2&quot; value=&quot;取消&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;b3&quot; value=&quot;反选&quot;&gt;&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    // 全选    $(&quot;#b1&quot;).on(&quot;click&quot;, function () &#123;        $(&quot;:checkbox&quot;).prop(&quot;checked&quot;, true);    &#125;);    // 取消    $(&quot;#b2&quot;).on(&quot;click&quot;, function () &#123;        $(&quot;:checkbox&quot;).prop(&quot;checked&quot;, false);    &#125;);    // 反选    $(&quot;#b3&quot;).on(&quot;click&quot;, function () &#123;        $(&quot;:checkbox&quot;).each(function () &#123;            var flag = $(this).prop(&quot;checked&quot;);            $(this).prop(&quot;checked&quot;, !flag)        &#125;);    &#125;);    // 定义一个全局变量    var flag = false    // 按住shift批量操作    // 全局事件, 监听键盘shift是否被按下    $(window).on(&quot;keydown&quot;, function (event) &#123;        if (event.keyCode === 16) &#123;            flag = true;        &#125;    &#125;)    // 全局事件, shift按键抬起时将全局变量设置为false    $(window).on(&quot;keyup&quot;, function (event) &#123;        if (event.keyCode === 16) &#123;            flag = false;        &#125;    &#125;)    $(&quot;table select&quot;).on(&quot;change&quot;, function () &#123;        // 判断是否是批量模式        if (flag) &#123;            var selectvalue = $(this).val();            // 找到所有被选中的那一行的select , 选中指定值            $(&quot;input:checked&quot;).parent().parent().find(&quot;select&quot;).val(selectvalue)        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;#&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;Egon&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;Alex&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;Yuan&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;EvaJ&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;        &lt;td&gt;Gold&lt;/td&gt;        &lt;td&gt;            &lt;select&gt;                &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;input type=&quot;button&quot; id=&quot;b1&quot; value=&quot;全选&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;b2&quot; value=&quot;取消&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;b3&quot; value=&quot;反选&quot;&gt;&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    // 定义一个全局变量    var flag = false    // 当shift按键按下时    $(window).keydown(function (event) &#123;        console.log(event.keyCode);        if (event.keyCode === 16) &#123;            flag = true;        &#125;    &#125;);    // 当shift按键抬起的时候    $(window).keyup(function (event) &#123;        console.log(event.keyCode);        if (event.keyCode === 16) &#123;            flag = false        &#125;    &#125;);    // select标签的值发生变化的时候,绑定change事件    $(&quot;select&quot;).change(function (event) &#123;        // 如果shift按键被按下, 进入批量操作模式        // shift对应的keyCode是16        // 判断当前select行有没有被选中        // console.log($(this).parent().siblings().first().find(&quot;:checkbox&quot;).prop(&quot;checked&quot;))        var ischecked = $(this).parent().siblings().first().find(&quot;:checkbox&quot;).prop(&quot;checked&quot;);        if (flag &amp;&amp; ischecked) &#123;            // 进入批量操作模式            // 1. 渠道当前select选中的值            var value = $(this).val();            // 2. 给其他被选中行的select设置成一样的值            // 2.1 先找到那些被选中行的select            // 2.2 给选中的select赋值            $(&quot;input:checked&quot;).parent().parent().find(&quot;select&quot;).val(value);        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ol><li><code>.on( events [, selector ],function()&#123;&#125;)</code></li></ol><ul><li>events： 事件</li><li>selector: 选择器（可选的）</li><li>function: 事件处理函数</li></ul><h3 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h3><ol><li><code>.off( events [, selector ][,function()&#123;&#125;])</code></li></ol><p><code>off()</code> 方法移除用 <code>.on()</code>绑定的事件处理程序。</p><ul><li>events： 事件</li><li>selector: 选择器（可选的）</li><li>function: 事件处理函数</li></ul><h3 id="阻止后续事件执行"><a href="#阻止后续事件执行" class="headerlink" title="阻止后续事件执行"></a>阻止后续事件执行</h3><ol><li><code>return false; // 常见阻止表单提交等</code></li><li>e.preventDefault();</li><li>e.stopProgation();</li></ol><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;阻止默认事件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt;    &lt;button id=&quot;b1&quot;&gt;点我&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    $(&quot;#b1&quot;).click(function (e) &#123;        alert(123);        //return false;        e.preventDefault();    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>注意：</p><p>像click、keydown等DOM中定义的事件，我们都可以使用<code>.on()</code>方法来绑定事件，但是<code>hover</code>这种jQuery中定义的事件就不能用<code>.on()</code>方法来绑定了。</p><p>想使用事件委托的方式绑定hover事件处理函数，可以参照如下代码分两步绑定事件：</p><pre><code>$(&#39;ul&#39;).on(&#39;mouseenter&#39;, &#39;li&#39;, function() &#123;//绑定鼠标进入事件    $(this).addClass(&#39;hover&#39;);&#125;);$(&#39;ul&#39;).on(&#39;mouseleave&#39;, &#39;li&#39;, function() &#123;//绑定鼠标划出事件    $(this).removeClass(&#39;hover&#39;);&#125;);</code></pre><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;阻止事件冒泡&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;p&gt;        &lt;span&gt;点我&lt;/span&gt;    &lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    $(&quot;span&quot;).click(function (e) &#123;        alert(&quot;span&quot;);        e.stopPropagation();    &#125;);    $(&quot;p&quot;).click(function () &#123;        alert(&quot;p&quot;);    &#125;);    $(&quot;div&quot;).click(function () &#123;        alert(&quot;div&quot;);    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="页面载入"><a href="#页面载入" class="headerlink" title="页面载入"></a>页面载入</h3><p>当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。</p><p>两种写法：</p><pre><code>$(document).ready(function()&#123;// 在这里写你的JS代码...&#125;)</code></pre><p>简写：</p><pre><code>$(function()&#123;// 你在这里写你的代码&#125;)</code></pre><p>文档加载完绑定事件，并且阻止默认事件发生：</p><h3 id="与window-onload的区别"><a href="#与window-onload的区别" class="headerlink" title="与window.onload的区别"></a>与window.onload的区别</h3><ul><li>window.onload()函数有覆盖现象，必须等待着图片资源加载完成之后才能调用</li><li>jQuery的这个入口函数没有函数覆盖现象，文档加载完成之后就可以调用（建议使用此函数）</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是通过事件冒泡的原理，利用父标签去捕获子标签的事件。</p><p>示例：</p><p>表格中每一行的编辑和删除按钮都能触发相应的事件。</p><pre><code>$(&quot;table&quot;).on(&quot;click&quot;, &quot;.delete&quot;, function () &#123;  // 删除按钮绑定的事件&#125;)</code></pre><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><pre><code>// 基本show([s,[e],[fn]])hide([s,[e],[fn]])toggle([s],[e],[fn])// 滑动slideDown([s],[e],[fn])slideUp([s,[e],[fn]])slideToggle([s],[e],[fn])// 淡入淡出fadeIn([s],[e],[fn])fadeOut([s],[e],[fn])fadeTo([[s],o,[e],[fn]])fadeToggle([s,[e],[fn]])// 自定义（了解即可）animate(p,[s],[e],[fn])</code></pre><p>自定义动画示例：</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><p><strong>jQuery.each(collection, callback(indexInArray, valueOfElement))：</strong></p><p>描述：一个通用的迭代函数，它可以用来无缝迭代对象和数组。数组和类似数组的对象通过一个长度属性（如一个函数的参数对象）来迭代数字索引，从0到length - 1。其他对象通过其属性名进行迭代。</p><pre><code>li =[10,20,30,40]$.each(li,function(i, v)&#123;  console.log(i, v);//index是索引，ele是每次循环的具体元素。&#125;)</code></pre><p>输出：</p><pre><code>010120230340</code></pre><p><strong>.each(function(index, Element))：</strong></p><p>描述：遍历一个jQuery对象，为每个匹配元素执行一个函数。</p><p><code>.each()</code> 方法用来迭代jQuery对象中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)。由于回调函数是在当前DOM元素为上下文的语境中触发的，所以关键字 <code>this</code> 总是指向这个元素。</p><pre><code>// 为每一个li标签添加foo$(&quot;li&quot;).each(function()&#123;  $(this).addClass(&quot;c1&quot;);&#125;);</code></pre><p>注意: jQuery的方法返回一个jQuery对象，遍历jQuery集合中的元素 - 被称为隐式<em>迭代</em>的过程。当这种情况发生时，它通常不需要显式地循环的 <code>.each()</code>方法：</p><p>也就是说，上面的例子没有必要使用each()方法，直接像下面这样写就可以了：</p><pre><code>$(&quot;li&quot;).addClass(&quot;c1&quot;);  // 对所有标签做统一操作</code></pre><p><strong>注意：</strong></p><p>在遍历过程中可以使用 <code>return false</code>提前结束each循环。</p><p><strong>终止each循环</strong></p><pre><code>return false；</code></pre><ul><li>each实例</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;444&lt;/div&gt;&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    $.each(a1, function (k, v) &#123;        if (v === 33) &#123;            return;  //表示跳出本次循环        &#125; else &#123;            console.log(v)        &#125;    &#125;)    $.each(a1, function (k, v) &#123;        if (v === 33) &#123;            return false;  // 表示结束循环        &#125; else &#123;            console.log(v);        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="data"><a href="#data" class="headerlink" title=".data()"></a>.data()</h3><p>在匹配的元素集合中的所有元素上存储任意相关数据或返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。</p><p><strong>.data(key, value):</strong></p><p>描述：在匹配的元素上存储任意相关数据。</p><pre><code>$(&quot;div&quot;).data(&quot;k&quot;,100);//给所有div标签都保存一个名为k，值为100</code></pre><p><strong>.data(key):</strong></p><p>描述: 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值—通过 <code>.data(name, value)</code>或 <code>HTML5 data-*</code>属性设置。</p><pre><code>$(&quot;div&quot;).data(&quot;k&quot;);//返回第一个div标签中保存的&quot;k&quot;的值</code></pre><p>.removeData(key):</p><p>描述：移除存放在元素上的数据，不加key参数表示移除所有保存的数据。</p><pre><code>$(&quot;div&quot;).removeData(&quot;k&quot;);  //移除元素上存放k对应的数据</code></pre><p>示例：</p><p>模态框编辑的数据回填表格</p><h3 id="插件-了解即可"><a href="#插件-了解即可" class="headerlink" title="插件(了解即可)"></a>插件(了解即可)</h3><p>jQuery.extend(object)</p><p>jQuery的命名空间下添加新的功能。多用于插件开发者向 jQuery 中添加新函数时使用。</p><p>示例：</p><pre><code>&lt;script&gt;jQuery.extend(&#123;  min:function(a, b)&#123;return a &lt; b ? a : b;&#125;,  max:function(a, b)&#123;return a &gt; b ? a : b;&#125;&#125;);jQuery.min(2,3);// =&gt; 2jQuery.max(4,5);// =&gt; 5&lt;/script&gt;</code></pre><p>jQuery.fn.extend(object)</p><p>一个对象的内容合并到jQuery的原型，以提供新的jQuery实例方法。</p><pre><code>&lt;script&gt;  jQuery.fn.extend(&#123;    check:function()&#123;      return this.each(function()&#123;this.checked =true;&#125;);    &#125;,    uncheck:function()&#123;      return this.each(function()&#123;this.checked =false;&#125;);    &#125;  &#125;);// jQuery对象可以使用新添加的check()方法了。$(&quot;input[type=&#39;checkbox&#39;]&quot;).check();&lt;/script&gt;</code></pre><p>单独写在文件中的扩展：</p><pre><code>(function(jq)&#123;  jq.extend(&#123;    funcName:function()&#123;    ...    &#125;,  &#125;);&#125;)(jQuery);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端JavaScript</title>
      <link href="/2021/05/20/%E5%89%8D%E7%AB%AFJavaScript-1/"/>
      <url>/2021/05/20/%E5%89%8D%E7%AB%AFJavaScript-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h1><p>到目前为止，我们已经学过了JavaScript的一些简单的语法。但是这些简单的语法，并没有和浏览器有任何交互。</p><p>也就是我们还不能制作一些我们经常看到的网页的一些交互，我们需要继续学习BOM和DOM相关知识。</p><p>JavaScript分为 ECMAScript，DOM，BOM。</p><p>BOM（Browser Object Model）是指浏览器对象模型，它使 JavaScript 有能力与浏览器进行“对话”。</p><p>DOM （Document Object Model）是指文档对象模型，通过它，可以访问HTML文档的所有元素。</p><p>Window对象是客户端JavaScript最高层对象之一，由于window对象是其它大部分对象的共同祖先，在调用window对象的方法和属性时，可以省略window对象的引用。例如：window.document.write()可以简写成：document.write()。</p><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>所有浏览器都支持 window 对象。它表示浏览器窗口。</p><p>*<em>如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</em></p><p>*<em>没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。</em></p><p>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p><p>全局变量是 window 对象的属性。全局函数是 window 对象的方法。</p><p>接下来要讲的HTML DOM 的 document 也是 window 对象的属性之一。</p><p>一些常用的Window方法：</p><ul><li>window.innerHeight - 浏览器窗口的内部高度</li><li>window.innerWidth - 浏览器窗口的内部宽度</li><li>window.open() - 打开新窗口</li><li>window.close() - 关闭当前窗口</li></ul><h2 id="window的子对象"><a href="#window的子对象" class="headerlink" title="window的子对象"></a>window的子对象</h2><h3 id="navigator对象（了解即可）"><a href="#navigator对象（了解即可）" class="headerlink" title="navigator对象（了解即可）"></a>navigator对象（了解即可）</h3><p>浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息。</p><pre><code>navigator.appName　　// Web浏览器全称navigator.appVersion　　// Web浏览器厂商和版本的详细字符串navigator.userAgent　　// 客户端绝大部分信息navigator.platform　　　// 浏览器运行所在的操作系统</code></pre><h3 id="screen对象（了解即可）"><a href="#screen对象（了解即可）" class="headerlink" title="screen对象（了解即可）"></a>screen对象（了解即可）</h3><p>屏幕对象，不常用。</p><p>一些属性：</p><ul><li>screen.availWidth - 可用的屏幕宽度</li><li>screen.availHeight - 可用的屏幕高度</li></ul><h3 id="history对象（了解即可）"><a href="#history对象（了解即可）" class="headerlink" title="history对象（了解即可）"></a>history对象（了解即可）</h3><p>window.history 对象包含浏览器的历史。</p><p>浏览历史对象，包含了用户对当前页面的浏览历史，但我们无法查看具体的地址，可以简单的用来前进或后退一个页面。</p><pre><code>history.forward()  // 前进一页history.back()  // 后退一页</code></pre><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</p><p>常用属性和方法：</p><pre><code>location.href  获取URLlocation.href=&quot;URL&quot; // 跳转到指定页面location.reload() 重新加载页面</code></pre><h3 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h3><p>可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框。</p><p><strong>警告框</strong></p><p>警告框经常用于确保用户可以得到某些信息。</p><p>当警告框出现后，用户需要点击确定按钮才能继续进行操作。</p><p>语法：</p><pre><code>alert(&quot;你看到了吗？&quot;);</code></pre><p><strong>确认框（了解即可）</strong></p><p>确认框用于使用户可以验证或者接受某些信息。</p><p>当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。</p><p>如果用户点击确认，那么返回值为 true。如果用户点击取消，那么返回值为 false。</p><p>语法：</p><pre><code>confirm(&quot;你确定吗？&quot;)</code></pre><p><strong>提示框（了解即可）</strong></p><p>提示框经常用于提示用户在进入页面前输入某个值。</p><p>当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。</p><p>如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。</p><p>语法：</p><pre><code>prompt(&quot;请在下方输入&quot;,&quot;你的答案&quot;)</code></pre><h3 id="计时相关"><a href="#计时相关" class="headerlink" title="计时相关"></a>计时相关</h3><p>通过使用 JavaScript，我们可以在一定时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。</p><p><strong>setTimeout()</strong></p><p>语法：</p><pre><code>var t=setTimeout(&quot;JS语句&quot;,毫秒)</code></pre><p>setTimeout() 方法会返回某个值。在上面的语句中，值被储存在名为 t 的变量中。假如你希望取消这个 setTimeout()，你可以使用这个变量名来指定它。</p><p>setTimeout() 的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 “alert(‘5 seconds!’)”，或者对函数的调用，诸如 alertMsg()”。</p><p>第二个参数指示从当前起多少毫秒后执行第一个参数（1000 毫秒等于一秒）。</p><p><strong>clearTimeout()</strong></p><p>语法：</p><pre><code>clearTimeout(setTimeout_variable)</code></pre><p>举个例子<strong>：</strong></p><pre><code>// 在指定时间之后执行一次相应函数var timer = setTimeout(function()&#123;alert(123);&#125;, 3000)// 取消setTimeout设置clearTimeout(timer);</code></pre><p><strong>setInterval()</strong></p><p>setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。</p><p>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。</p><p>语法：</p><pre><code>setInterval(&quot;JS语句&quot;,时间间隔)</code></pre><p>返回值</p><p>一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。</p><p><strong>clearInterval()</strong></p><p>clearInterval() 方法可取消由 setInterval() 设置的 timeout。</p><p>clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。</p><p>语法：</p><pre><code>clearInterval(setinterval返回的ID值)</code></pre><p>举个例子：</p><pre><code>// 每隔一段时间就执行一次相应函数var timer = setInterval(function()&#123;console.log(123);&#125;, 3000)// 取消setInterval设置clearInterval(timer);</code></pre><p>稍微大一点的示例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;定时器&lt;/title&gt;  &lt;script&gt;    var intervalId;    function f() &#123;      var timeStr = (new Date()).toLocaleString();      var inputEle = document.getElementById(&quot;i1&quot;);      inputEle.value = timeStr;    &#125;    function start() &#123;      f();      if (intervalId === undefined) &#123;        intervalId = setInterval(f, 1000);      &#125;    &#125;    function end() &#123;      clearInterval(intervalId);      intervalId = undefined;    &#125;  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;i1&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;开始&quot; id=&quot;start&quot; onclick=&quot;start();&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;结束&quot; id=&quot;end&quot; onclick=&quot;end();&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM（Document Object Model）是一套对文档的内容进行抽象和概念化的方法。 </p><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。</p><p>HTML DOM 模型被构造为对象的树。</p><h2 id="HTML-DOM-树"><a href="#HTML-DOM-树" class="headerlink" title="HTML DOM 树"></a>HTML DOM 树</h2><p>DOM标准规定HTML文档中的每个成分都是一个节点(node)：</p><ul><li>文档节点(document对象)：代表整个文档</li><li>元素节点(element 对象)：代表一个元素（标签）</li><li>文本节点(text对象)：代表元素（标签）中的文本</li><li>属性节点(attribute对象)：代表一个属性，元素（标签）才有属性</li><li>注释是注释节点(comment对象)　</li></ul><p>JavaScript 可以通过DOM创建动态的 HTML：</p><ul><li>JavaScript 能够改变页面中的所有 HTML 元素</li><li>JavaScript 能够改变页面中的所有 HTML 属性</li><li>JavaScript 能够改变页面中的所有 CSS 样式</li><li>JavaScript 能够对页面中的所有事件做出反应</li></ul><h2 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h2><h3 id="直接查找"><a href="#直接查找" class="headerlink" title="直接查找"></a>直接查找</h3><pre><code>document.getElementById           根据ID获取一个标签document.getElementsByClassName   根据class属性获取document.getElementsByTagName     根据标签名获取标签合集</code></pre><p>注意：</p><p>涉及到DOM操作的JS代码应该放在文档的哪个位置。</p><h3 id="间接查找"><a href="#间接查找" class="headerlink" title="间接查找"></a>间接查找</h3><pre><code>parentElement            父节点标签元素children                 所有子标签firstElementChild        第一个子标签元素lastElementChild         最后一个子标签元素nextElementSibling       下一个兄弟标签元素previousElementSibling   上一个兄弟标签元素</code></pre><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>语法：</p><p>createElement(标签名)</p><p>示例：</p><pre><code>var divEle = document.createElement(&quot;div&quot;);</code></pre><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>语法：</p><p>追加一个子节点（作为最后的子节点）</p><p>somenode.appendChild(newnode)；</p><p>把增加的节点放到某个节点的前边。</p><p>somenode.insertBefore(newnode,某个节点);</p><p>示例：</p><pre><code>var imgEle=document.createElement(&quot;img&quot;);imgEle.setAttribute(&quot;src&quot;, &quot;http://image11.m1905.cn/uploadfile/s2010/0205/20100205083613178.jpg&quot;);var d1Ele = document.getElementById(&quot;d1&quot;);d1Ele.appendChild(imgEle);</code></pre><h3 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h3><p>语法：</p><p>获得要删除的元素，通过父元素调用该方法删除。</p><p>somenode.removeChild(要删除的节点)</p><h3 id="替换节点："><a href="#替换节点：" class="headerlink" title="替换节点："></a>替换节点：</h3><p>语法：</p><p>somenode.replaceChild(newnode, 某个节点);</p><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>获取文本节点的值：</p><pre><code>var divEle = document.getElementById(&quot;d1&quot;)divEle.innerTextdivEle.innerHTML</code></pre><p>设置文本节点的值：</p><pre><code>var divEle = document.getElementById(&quot;d1&quot;)divEle.innerText=&quot;1&quot;divEle.innerHTML=&quot;&lt;p&gt;2&lt;/p&gt;&quot;</code></pre><p><strong>attribute操作</strong></p><pre><code>var divEle = document.getElementById(&quot;d1&quot;);divEle.setAttribute(&quot;age&quot;,&quot;18&quot;)divEle.getAttribute(&quot;age&quot;)divEle.removeAttribute(&quot;age&quot;)// 自带的属性还可以直接.属性名来获取和设置imgEle.srcimgEle.src=&quot;...&quot;</code></pre><h3 id="获取值操作"><a href="#获取值操作" class="headerlink" title="获取值操作"></a>获取值操作</h3><p>语法：</p><p>elementNode.value</p><p>适用于以下标签：</p><ul><li>.input  </li><li>.select</li><li>.textarea </li></ul><pre><code>var iEle = document.getElementById(&quot;i1&quot;);console.log(iEle.value);var sEle = document.getElementById(&quot;s1&quot;);console.log(sEle.value);var tEle = document.getElementById(&quot;t1&quot;);console.log(tEle.value);</code></pre><h3 id="class的操作"><a href="#class的操作" class="headerlink" title="class的操作"></a>class的操作</h3><pre><code>className  获取所有样式类名(字符串)classList.remove(cls)  删除指定类classList.add(cls)  添加类classList.contains(cls)  存在返回true，否则返回falseclassList.toggle(cls)  存在就删除，否则添加</code></pre><h3 id="指定CSS操作"><a href="#指定CSS操作" class="headerlink" title="指定CSS操作"></a><strong>指定CSS操作</strong></h3><pre><code>obj.style.backgroundColor=&quot;red&quot;</code></pre><p>JS操作CSS属性的规律：</p><p>1.对于没有中横线的CSS属性一般直接使用style.属性名即可。如：</p><pre><code>obj.style.marginobj.style.widthobj.style.leftobj.style.position</code></pre><p>2.对含有中横线的CSS属性，将中横线后面的第一个字母换成大写即可。如：</p><pre><code>obj.style.marginTopobj.style.borderLeftWidthobj.style.zIndexobj.style.fontFamily</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。</p><h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><pre><code>onclick        当用户点击某个对象时调用的事件句柄。ondblclick     当用户双击某个对象时调用的事件句柄。onfocus        元素获得焦点。               // 练习：输入框onblur         元素失去焦点。               应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.onchange       域的内容被改变。             应用场景：通常用于表单元素,当元素内容被改变时触发.（select联动）onkeydown      某个键盘按键被按下。          应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.onkeypress     某个键盘按键被按下并松开。onkeyup        某个键盘按键被松开。onload         一张页面或一幅图像完成加载。onmousedown    鼠标按钮被按下。onmousemove    鼠标被移动。onmouseout     鼠标从某元素移开。onmouseover    鼠标移到某元素之上。onselect      在文本框中的文本被选中时发生。onsubmit      确认按钮被点击，使用的对象是form。</code></pre><h3 id="绑定方式："><a href="#绑定方式：" class="headerlink" title="绑定方式："></a>绑定方式：</h3><h6 id="操作标签的样式"><a href="#操作标签的样式" class="headerlink" title="操作标签的样式"></a>操作标签的样式</h6><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        .c&#123;            height: 200px;            width: 200px;            background-color: green;            border-radius: 50%;        &#125;        .c1&#123;            background-color: red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id = &quot;d1&quot; class = &quot;c c1&quot;&gt;&lt;/div&gt;&lt;button id = &quot;b1&quot; onclick = &quot;change(); &quot;&gt;点我1&lt;/button&gt;&lt;input id = &quot;b2&quot; type=&quot;button&quot; value=&quot;点我2&quot;&gt;&lt;script&gt;    function change()&#123;        var d1Ele = document.getElementById(&quot;d1&quot;);        d1Ele.classList.toggle(&quot;c1&quot;);    &#125;    //通过JS给标签绑定事件    //这种方式常用    var b2Ele = document.getElementById(&quot;b2&quot;);    b2Ele.onclick = function (ev) &#123;        console.log(this);        //this表示触发事件的标签本身        var d1Ele = document.getElementById(&quot;d1&quot;);        d1Ele.classList.toggle(&quot;c1&quot;)    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>input获取焦点和失去焦点事件</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;i1&quot; value=&quot;对子哈特&quot;&gt;&lt;script&gt;    // 找到要绑定事件的标签    var i1Ele = document.getElementById(&quot;i1&quot;);    // 1. 先绑定获取焦点的事件    i1Ele.onfocus = function (ev) &#123;        // 当输入框获取焦点之后要做的事儿        this.value = &quot;&quot;;    &#125;;    // 2. 绑定失去焦点的事件    i1Ele.onblur = function (ev) &#123;        this.value = &quot;对子哈特&quot;;    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>方式一：</p><pre><code>&lt;div id=&quot;d1&quot; onclick=&quot;changeColor(this);&quot;&gt;点我&lt;/div&gt;&lt;script&gt;  function changeColor(ths) &#123;    ths.style.backgroundColor=&quot;green&quot;;  &#125;&lt;/script&gt;</code></pre><p>注意：</p><h5 id="this是实参，表示触发事件的当前元素。"><a href="#this是实参，表示触发事件的当前元素。" class="headerlink" title="this是实参，表示触发事件的当前元素。"></a>this是实参，表示触发事件的当前元素。</h5><p>函数定义过程中的ths为形参。</p><p>方式二：</p><pre><code>&lt;div id=&quot;d2&quot;&gt;点我&lt;/div&gt;&lt;script&gt;  var divEle2 = document.getElementById(&quot;d2&quot;);  divEle2.onclick=function () &#123;    this.innerText=&quot;呵呵&quot;;  &#125;&lt;/script&gt;</code></pre><p>事件示例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;搜索框示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;d1&quot; type=&quot;text&quot; value=&quot;请输入关键字&quot; onblur=&quot;blur()&quot; onfocus=&quot;focus()&quot;&gt;&lt;script&gt;function focus()&#123;    var inputEle=document.getElementById(&quot;d1&quot;);    if (inputEle.value===&quot;请输入关键字&quot;)&#123;        inputEle.value=&quot;&quot;;    &#125;&#125;function blur()&#123;    var inputEle=document.getElementById(&quot;d1&quot;);    var val=inputEle.value;    if(!val.trim())&#123;        inputEle.value=&quot;请输入关键字&quot;;    &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="select联动"><a href="#select联动" class="headerlink" title="select联动"></a>select联动</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;label for=&quot;s1&quot;&gt;省&lt;/label&gt;&lt;select id=&quot;s1&quot;&gt;    &lt;option value=&quot;&quot;&gt;请选择省&lt;/option&gt;&lt;/select&gt;&lt;label for=&quot;s2&quot;&gt;市&lt;/label&gt;&lt;select  id=&quot;s2&quot;&gt;&lt;/select&gt;&lt;script&gt;    var data = &#123;        &quot;甘肃&quot;:[&quot;兰州市&quot;,&quot;定西市&quot;,&quot;武威市&quot;],        &quot;广东&quot;:[&quot;广州市&quot;,&quot;深圳市&quot;,&quot;韶关市&quot;],        &quot;江苏&quot;:[&quot;苏州市&quot;,&quot;南京市&quot;,&quot;常州市&quot;]    &#125;;    var s1Ele = document.getElementById(&quot;s1&quot;);    var s2Ele = document.getElementById(&quot;s2&quot;);    //拿到所有省,在s1中生成对应的option选项    for (var i in data)&#123;        console.log(i)        //创建option标签        var tmp = document.createElement(&quot;option&quot;);        //把省信息添加到option中        tmp.innerText = i;        //把创建好的option标签插入到第一个select标签中        s1Ele.appendChild(tmp);    &#125;    //当用户选中某个省之后才做的事    //当第一个select框的值发生变化的时候触发的事件    s1Ele.onchange = function (ev) &#123;        // 先清空第二个select框的option        s2Ele.innerHTML = &quot;&quot;;        //获取用户选择的省        console.log(this.value);        var p = this.value;        //根据用户选择的省,对应对data中找省对应的城市数据        var cityArray = data[p];        // 遍历所有的城市数据, 给第二个select框添加option选项        for (var j in cityArray)&#123;            console.log(cityArray[j]);            // 生成空的option            var tmp = document.createElement(&quot;option&quot;);            //给option添加文本            tmp.innerText = cityArray[j];            //把生成的option追加到第二个select标签中            s2Ele.appendChild(tmp);        &#125;    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;select联动&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;select id=&quot;province&quot;&gt;  &lt;option&gt;请选择省:&lt;/option&gt;&lt;/select&gt;&lt;select id=&quot;city&quot;&gt;  &lt;option&gt;请选择市:&lt;/option&gt;&lt;/select&gt;&lt;script&gt;  data = &#123;&quot;河北省&quot;: [&quot;廊坊&quot;, &quot;邯郸&quot;], &quot;北京&quot;: [&quot;朝阳区&quot;, &quot;海淀区&quot;], &quot;山东&quot;: [&quot;威海市&quot;, &quot;烟台市&quot;]&#125;;  var p = document.getElementById(&quot;province&quot;);  var c = document.getElementById(&quot;city&quot;);  for (var i in data) &#123;    var optionP = document.createElement(&quot;option&quot;);    optionP.innerHTML = i;    p.appendChild(optionP);  &#125;  p.onchange = function () &#123;    var pro = (this.options[this.selectedIndex]).innerHTML;    var citys = data[pro];    // 清空option    c.innerHTML = &quot;&quot;;    for (var i=0;i&lt;citys.length;i++) &#123;      var option_city = document.createElement(&quot;option&quot;);      option_city.innerHTML = citys[i];      c.appendChild(option_city);    &#125;  &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h2><p>当我们给页面上的元素绑定事件的时候，必须等到文档加载完毕。因为我们无法给一个不存在的元素绑定事件。</p><p>window.onload事件在文件加载过程结束的时候触发。此时，文档中的所有对象都位于DOM中，并且所有图像，脚本，链接和子框架都已完成加载。</p><p>注意：.onload()函数存在覆盖现象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端基础之BOM和BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端JavaScript</title>
      <link href="/2021/05/08/%E5%89%8D%E7%AB%AFJavaScript/"/>
      <url>/2021/05/08/%E5%89%8D%E7%AB%AFJavaScript/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h3><h4 id="一-ECMAScript和JavaScript的关系"><a href="#一-ECMAScript和JavaScript的关系" class="headerlink" title="一.ECMAScript和JavaScript的关系"></a>一.ECMAScript和JavaScript的关系</h4><ul><li><p>1996年11月，JavaScript的创造者–Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这门语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。</p><p>该标准一开始就是针对JavaScript语言制定的，但是没有称其为JavaScript，有两个方面的原因。一是商标，JavaScript本身已被Netscape注册为商标。二是想体现这门语言的制定者是ECMA，而不是Netscape，这样有利于保证这门语言的开发性和中立性。</p><p>因此ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现</p></li></ul><h4 id="二-ECMAScript的历史"><a href="#二-ECMAScript的历史" class="headerlink" title="二.ECMAScript的历史"></a>二.ECMAScript的历史</h4><ul><li><table><thead><tr><th>年份</th><th align="left">名称</th><th>描述</th></tr></thead><tbody><tr><td>1997</td><td align="left">ECMAScript 1</td><td>第一个版本</td></tr><tr><td>1998</td><td align="left">ECMAScript 2</td><td>版本变更</td></tr><tr><td>1999</td><td align="left">ECMAScript 3</td><td>添加正则表达式添加try/catch</td></tr><tr><td></td><td align="left">ECMAScript 4</td><td>没有发布</td></tr><tr><td>2009</td><td align="left">ECMAScript 5</td><td>添加”strict mode”严格模式添加JSON支持</td></tr><tr><td>2011</td><td align="left">ECMAScript 5.1</td><td>版本变更</td></tr><tr><td>2015</td><td align="left">ECMAScript 6</td><td>添加类和模块</td></tr><tr><td>2016</td><td align="left">ECMAScript 7</td><td>增加指数运算符（**）增加Array.prototype.includes</td></tr></tbody></table></li><li><p>注: ES6就是指ECMAScript6</p></li><li><p>尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的： </p><ul><li>核心 (ECMAScript)</li><li>文档对象模型(DOM)  Document object model  (整合js, css, html)</li><li>浏览器对象模型(BOM) Broswer object model  (整合js 和浏览器)</li></ul><p>简单地说，ECMAScript 描述了JavaScript语言本身的相关内容。</p><p>JavaScript 是脚本语言<br>JavaScript 是一种轻量级的编程语言。</p><p>JavaScript 是可插入 HTML 页面的编程代码。</p><p>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</p><p>JavaScript 很容易学习。</p></li></ul><h4 id="三-JavaScript引入方式"><a href="#三-JavaScript引入方式" class="headerlink" title="三.JavaScript引入方式"></a>三.JavaScript引入方式</h4><p>1.Script标签内写代码</p><pre><code>&lt;script&gt;  //这里写代码 &lt;/script&gt;</code></pre><p>2.引入额外的JS文件</p><pre><code>&lt;script src=&quot;文件名.js&quot;&gt;&lt;/script&gt;</code></pre><p>3.JavaScript语言规范</p><pre><code>//  这是单行注释/*这是多行注释*/JavaScript中的语句要以分号为结束符</code></pre><h4 id="四-JavaScript语言基础"><a href="#四-JavaScript语言基础" class="headerlink" title="四.JavaScript语言基础"></a>四.JavaScript语言基础</h4><ul><li><h6 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h6><ul><li>JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。</li><li>声明变量使用 var 变量名; 的格式来进行声明</li></ul><pre><code>var name = &quot;Alex&quot;;var age = 18;</code></pre><p>注意: 变量名是区分大小写的。推荐使用驼峰式命名规则。保留字不能用做变量名。</p><p>补充:  <em>ES6新增了let命令，用于声明变量。其用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。例如：for循环的计数器就很适合使用let命令。</em> </p><pre><code>for (let i=0;i&lt;arr.length;i++)&#123;...&#125;</code></pre><p> <em>ES6新增const用来声明常量。一旦声明，其</em> 值就不能改变</p><pre><code>const PI = 3.1415;PI // 3.1415PI = 3// TypeError: &quot;PI&quot; is read-only</code></pre></li></ul><h4 id="五-JavaScript数据类型"><a href="#五-JavaScript数据类型" class="headerlink" title="五.JavaScript数据类型"></a>五.JavaScript数据类型</h4><ul><li><h6 id="JavaScript拥有动态类型"><a href="#JavaScript拥有动态类型" class="headerlink" title="JavaScript拥有动态类型"></a>JavaScript拥有动态类型</h6><pre><code>var x;  // 此时x是undefinedvar x = 1;  // 此时x是数字var x = &quot;Alex&quot;  // 此时x是字符串</code></pre></li><li><h6 id="数值-Number"><a href="#数值-Number" class="headerlink" title="数值(Number)"></a>数值(Number)</h6><p> JavaScript不区分整型和浮点型，就只有一种数字类型</p><pre><code>var a = 12.34;var b = 20;var c = 123e5;  // 12300000var d = 123e-5;  // 0.00123</code></pre><p> 还有一种NaN，表示不是一个数字 (Not a Number)</p><pre><code>parseInt(&quot;123&quot;)  // 返回123parseInt(&quot;ABC&quot;)  // 返回NaN,NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。parseFloat(&quot;123.456&quot;)  // 返回123.456</code></pre></li><li><h6 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h6><pre><code>var a = &quot;Hello&quot;var b = &quot;world;var c = a + b; console.log(c);  // 得到Helloworld</code></pre></li><li><h6 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.length</td><td>返回长度</td></tr><tr><td>.trim()</td><td>移除空白</td></tr><tr><td>.trimLeft()</td><td>移除左边的空白</td></tr><tr><td>.trimRight()</td><td>移除右边的空白</td></tr><tr><td>.charAt(n)</td><td>返回第n个字符</td></tr><tr><td>.concat(value, …)</td><td>拼接</td></tr><tr><td>.indexOf(substring, start)</td><td>子序列位置</td></tr><tr><td>.substring(from, to)</td><td>根据索引获取子序列</td></tr><tr><td>.slice(start, end)</td><td>切片</td></tr><tr><td>.toLowerCase()</td><td>小写</td></tr><tr><td>.toUpperCase()</td><td>大写</td></tr><tr><td>.split(delimiter, limit)</td><td>分割</td></tr></tbody></table></li><li><h6 id="拼接字符串一般使用“-”"><a href="#拼接字符串一般使用“-”" class="headerlink" title="拼接字符串一般使用“+”"></a>拼接字符串一般使用“+”</h6><pre><code>string.slice(start, stop)和string.substring(start, stop)：两者的相同点：如果start等于end，返回空字符串如果stop参数省略，则取到字符串末如果某个参数超过string的长度，这个参数会被替换为string的长度substirng()的特点：如果 start &gt; stop ，start和stop将被交换如果参数是负数或者不是数字，将会被0替换silce()的特点：如果 start &gt; stop 不会交换两者如果start小于0，则切割从字符串末尾往前数的第abs(start)个的字符开始(包括该位置的字符)如果stop小于0，则切割在从字符串末尾往前数的第abs(stop)个字符结束(不包含该位置字符)</code></pre></li><li><h6 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h6><p><em>ES6中引入了模板字符串。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</em></p><pre><code>// 普通字符串`这是普通字符串！`// 多行文本`这是多行的文本`// 字符串中嵌入变量var name = &quot;q1mi&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</code></pre></li><li><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><p>如果模板字符串中需要使用反引号，则在其前面要用反斜杠转义。</p><p>JSHint启用ES6语法支持:/* jshint esversion: 6*/</p></li><li><h6 id="布尔值-Boolean"><a href="#布尔值-Boolean" class="headerlink" title="布尔值(Boolean)"></a>布尔值(Boolean)</h6><p>区别于Python，true和false都是小写。</p><pre><code>var a = true;var b = false;</code></pre><h5 id="“”-空字符串-、0、null、undefined、NaN都是-false"><a href="#“”-空字符串-、0、null、undefined、NaN都是-false" class="headerlink" title="“”(空字符串)、0、null、undefined、NaN都是 false"></a>“”(空字符串)、0、null、undefined、NaN都是 false</h5></li><li><h6 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h6><ul><li>null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null;</li><li>undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。还有就是函数无明确的返回值时，返回的也是undefined。</li></ul><p>null表示变量的值是空，undefined则表示只声明了变量, 单还没有赋值</p></li><li><h6 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象(Object)"></a>对象(Object)</h6><p>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…此外，JavaScript 允许自定义对象。</p><p>JavaScript 提供多个内建对象，比如 String、Date、Array 等等。</p><p>对象只是带有属性和方法的特殊数据类型。</p></li><li><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><ul><li>数组对象的作用是：使用单独的变量名来存储一系列的值。类似于Python中的列表。 </li></ul><pre><code>var a = [123, &quot;ABC&quot;];console.log(a[1]);  // 输出&quot;ABC&quot;</code></pre><ul><li>常用方法</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.length</td><td>数组的大小</td></tr><tr><td>.push(ele)</td><td>尾部追加元素</td></tr><tr><td>.pop()</td><td>获取尾部的元素</td></tr><tr><td>.unshift(ele)</td><td>头部插入元素</td></tr><tr><td>.shift()</td><td>头部移除元素</td></tr><tr><td>.slice(start, end)</td><td>切片</td></tr><tr><td>.reverse()</td><td>反转</td></tr><tr><td>.join(seq)</td><td>将数组元素连接成字符串</td></tr><tr><td>.concat(val, …)</td><td>连接数组</td></tr><tr><td>.sort()</td><td>排序</td></tr><tr><td>.forEach()</td><td>将数组的每个元素传递给回调函数</td></tr><tr><td>.splice()</td><td>删除元素，并向数组添加新元素。</td></tr><tr><td>.map()</td><td>返回一个数组元素调用函数处理 后的的值得新数组</td></tr></tbody></table><h6 id="关于sort-需要注意："><a href="#关于sort-需要注意：" class="headerlink" title="关于sort()需要注意："></a>关于sort()需要注意：</h6><p>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p><p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p></li></ul><pre><code>function sortNumber(a,b)&#123;    return a - b&#125;var arr1 = [11, 100, 22, 55, 33, 44]arr1.sort(sortNumber)</code></pre><p> 关于遍历数组中的元素，可以使用下面的方式:</p><pre><code>var a = [10, 20, 30, 40];for (var i=0;i&lt;a.length;i++) &#123;  console.log(a[i]);&#125;</code></pre><ul><li><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h6><ul><li>forEach(function(currentValue, index, arr), thisValue</li></ul><p>参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>function(currentValue, index, arr)</em></td><td>必需。 数组中每个元素需要调用的函数。 函数参数:  参数描述<em>currentValue</em> 必需。当前元素                                                                      <em>index</em>   可选。当前元素的索引值。                                                                   arr 可选。当前元素所属的数组对象。</td></tr><tr><td><em>thisValue</em></td><td>可选。传递给函数的值一般用 “this” 值。 如果这个参数为空，”undefined”会传递给”this”值</td></tr></tbody></table></li><li><h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><ul><li>splice(index,howmany,item 1,……,itemX)</li></ul><p>参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>index</em></td><td>必需。规定从何处添加/删除元素。 该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</td></tr><tr><td><em>howmany</em></td><td>必需。规定应该删除多少元素。必须是数字，但可以是 “0”。 如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</td></tr><tr><td><em>item1</em>, …, <em>itemX</em></td><td>可选。要添加到数组的新元素</td></tr></tbody></table></li><li><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><ul><li>map(function(currentValue,index,arr), thisValue)</li></ul><p>参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>function(currentValue, index,arr)</em></td><td>必须。函数，数组中的每个元素都会执行这个函数                                        函数参数:                                                                                                            参数描述                                                                                                 <em>currentValue</em>必须。当前元素的值                                                                     <em>index</em>可选。当前元素的索引值                                                                               <em>arr</em>可选。当前元素属于的数组对象</td></tr><tr><td><em>thisValue</em></td><td>可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。<br/>如果省略了 thisValue,  “this” 的值为”undefined”</td></tr></tbody></table></li><li><p>补充</p><ul><li><em>ES6新引入了一种新的原始数据类型（Symbol），表示独一无二的值。它是JavaScript语言的第7种数据类型。</em> </li></ul></li></ul><h3 id="六-类型查询"><a href="#六-类型查询" class="headerlink" title="六.类型查询"></a>六.类型查询</h3><pre><code>typeof &quot;abc&quot;  // &quot;string&quot;typeof null  // &quot;object&quot;typeof true  // &quot;boolean&quot;typeof 123 // &quot;number&quot;</code></pre><p>​    typeof是一个一元运算符（就像++，–，！，- 等一元运算符），不是一个函数，也不是一个语句。</p><p>对变量或值调用 typeof 运算符将返回下列值之一:</p><ul><li>undefined - 如果变量是 Undefined 类型的</li><li>boolean - 如果变量是 Boolean 类型的</li><li>number - 如果变量是 Number 类型的</li><li>string - 如果变量是 String 类型的</li><li>object - 如果变量是一种引用类型或 Null 类型的</li></ul><h3 id="七-运算符"><a href="#七-运算符" class="headerlink" title="七.运算符"></a>七.运算符</h3><h5 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h5><pre><code>+ - * / % ++ --</code></pre><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><strong>比较运算符</strong></h5><pre><code>&gt; &gt;= &lt; &lt;= != == === !==</code></pre><p>注意：</p><pre><code>1 == “1”  // true1 === &quot;1&quot;  // false</code></pre><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h5><pre><code>&amp;&amp; || !</code></pre><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h5><pre><code>= += -= *= /=</code></pre><h5 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h5><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><pre><code>var a = 10;if (a &gt; 5)&#123;  console.log(&quot;yes&quot;);&#125;else &#123;  console.log(&quot;no&quot;);&#125;</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if-else if-else"></a>if-else if-else</h3><pre><code>var a = 10;if (a &gt; 5)&#123;  console.log(&quot;a &gt; 5&quot;);&#125;else if (a &lt; 5) &#123;  console.log(&quot;a &lt; 5&quot;);&#125;else &#123;  console.log(&quot;a = 5&quot;);&#125;</code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><pre><code>var day = new Date().getDay();switch (day) &#123;  case 0:  console.log(&quot;Sunday&quot;);  break;  case 1:  console.log(&quot;Monday&quot;);  break;default:  console.log(&quot;...&quot;)&#125;</code></pre><p>switch中的case子句通常都会加break语句，否则程序会继续执行后续case中的语句。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><pre><code>for (var i=0;i&lt;10;i++) &#123;  console.log(i);&#125;</code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code>var i = 0;while (i &lt; 10) &#123;  console.log(i);  i++;&#125;</code></pre><h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><pre><code>var a = 1;var b = 2;var c = a &gt; b ? a : b</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>JavaScript中的函数和Python中的非常类似，只是定义方式有点区别。</p><pre><code>// 普通函数定义function f1() &#123;  console.log(&quot;Hello world!&quot;);&#125;// 带参数的函数function f2(a, b) &#123;  console.log(arguments);  // 内置的arguments对象  console.log(arguments.length);  console.log(a, b);&#125;// 带返回值的函数function sum(a, b)&#123;  return a + b;&#125;sum(1, 2);  // 调用函数// 匿名函数方式var sum = function(a, b)&#123;  return a + b;&#125;sum(1, 2);// 立即执行函数(function(a, b)&#123;  return a + b;&#125;)(1, 2);</code></pre><p><em>补充：</em></p><p>ES6中允许使用“箭头”（=&gt;）定义函数。</p><pre><code>var f = v =&gt; v;// 等同于var f = function(v)&#123;  return v;&#125;</code></pre><p>如果箭头函数不需要参数或需要多个参数，就是用圆括号代表参数部分：</p><pre><code>var f = () =&gt; 5;// 等同于var f = function()&#123;return 5&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2)&#123;  return num1 + num2;&#125;</code></pre><h3 id="函数中的arguments参数"><a href="#函数中的arguments参数" class="headerlink" title="函数中的arguments参数"></a>函数中的arguments参数</h3><pre><code>function add(a,b)&#123;  console.log(a+b);  console.log(arguments.length)&#125;add(1,2)</code></pre><p>输出：</p><pre><code>32</code></pre><p><em>注意：</em></p><p>函数只能返回一个值，如果要返回多个值，只能将其放在数组或对象中返回。</p><h3 id="函数的全局变量和局部变量"><a href="#函数的全局变量和局部变量" class="headerlink" title="函数的全局变量和局部变量"></a>函数的全局变量和局部变量</h3><p><strong>局部变量</strong>：</p><p>在JavaScript函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。只要函数运行完毕，本地变量就会被删除。</p><p><strong>全局变量：</strong></p><p>在函数外声明的变量是<em>全局</em>变量，网页上的所有脚本和函数都能访问它。</p><p><strong>变量生存周期：</strong></p><p>JavaScript变量的生命期从它们被声明的时间开始。</p><p>局部变量会在函数运行以后被删除。</p><p>全局变量会在页面关闭后被删除。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>首先在函数内部查找变量，找不到则到外层函数查找，逐步找到最外层。</p><p><strong>几个例子：</strong></p><p>1.</p><pre><code>var city = &quot;BeiJing&quot;;function f() &#123;  var city = &quot;ShangHai&quot;;  function inner()&#123;    var city = &quot;ShenZhen&quot;;    console.log(city);  &#125;  inner();&#125;f();  //输出结果是？输出结果是:ShenZhen</code></pre><p>2.</p><pre><code>var city = &quot;BeiJing&quot;;function Bar() &#123;  console.log(city);&#125;function f() &#123;  var city = &quot;ShangHai&quot;;  return Bar;&#125;var ret = f();ret();  // 打印结果是？输出结果是:BeiJing</code></pre><p>3.闭包</p><pre><code>var city = &quot;BeiJing&quot;;function f()&#123;    var city = &quot;ShangHai&quot;;    function inner()&#123;        console.log(city);    &#125;    return inner;&#125;var ret = f();ret();输出结果是:ShanHai</code></pre><h2 id="词法分析（尝试理解）"><a href="#词法分析（尝试理解）" class="headerlink" title="词法分析（尝试理解）"></a>词法分析（尝试理解）</h2><p>JavaScript中在调用函数的那一瞬间，会先进行词法分析。</p><p><strong>词法分析的过程：</strong></p><p>当函数调用的前一瞬间，会先形成一个激活对象：Avtive Object（AO），并会分析以下3个方面：</p><p>1:函数参数，如果有，则将此参数赋值给AO，且值为undefined。如果没有，则不做任何操作。<br>2:函数局部变量，如果AO上有同名的值，则不做任何操作。如果没有，则将此变量赋值给AO，并且值为undefined。<br>3:函数声明，如果AO上有，则会将AO上的对象覆盖。如果没有，则不做任何操作。</p><p>函数内部无论是使用参数还是使用局部变量都到AO上找。</p><p>看两个例子：</p><pre><code>var age = 18;function foo()&#123;  console.log(age);  var age = 22;  console.log(age);&#125;foo();  // 问：执行foo()之后的结果是？</code></pre><p>第二题：</p><pre><code>var age = 18;function foo()&#123;  console.log(age);  var age = 22;  console.log(age);  function age()&#123;    console.log(&quot;呵呵&quot;);  &#125;  console.log(age);&#125;foo();  // 执行后的结果是？</code></pre><p> 答案解析</p><pre><code>词法分析过程：1、分析参数，有一个参数，形成一个 AO.age=undefine;2、分析变量声明，有一个 var age, 发现 AO 上面已经有一个 AO.age，因此不做任何处理3、分析函数声明，有一个 function age()&#123;...&#125; 声明， 则把原有的 age 覆盖成 AO.age=function()&#123;...&#125;;最终，AO上的属性只有一个age，并且值为一个函数声明执行过程：注意：执行过程中所有的值都是从AO对象上去寻找1、执行第一个 console.log(age) 时，此时的 AO.age 是一个函数，所以第一个输出的一个函数2、这句 var age=22; 是对 AO.age 的属性赋值， 此时AO.age=22 ，所以在第二个输出的是 23、同理第三个输出的还是22, 因为中间再没有改变age值得语句了</code></pre><h2 id="内置对象和方法"><a href="#内置对象和方法" class="headerlink" title="内置对象和方法"></a>内置对象和方法</h2><p>JavaScript中的所有事物都是对象：字符串、数字、数组、日期，等等。在JavaScript中，对象是拥有属性和方法的数据。</p><p>我们在学习基本数据类型的时候已经带大家了解了，JavaScript中的Number对象、String对象、Array对象等。</p><p>注意var s1 = “abc”和var s2 = new String(“abc”)的区别：typeof s1 –&gt; string而 typeof s2 –&gt; Object</p><table><thead><tr><th align="center">类型</th><th align="center">内置对象</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">数据类型(3个)</td><td align="center">Number</td><td align="center">数字对象</td></tr><tr><td align="center"></td><td align="center">String</td><td align="center">字符串对象</td></tr><tr><td align="center"></td><td align="center">Boolean</td><td align="center">布尔值对象</td></tr><tr><td align="center">组合对象(3个)</td><td align="center">Array</td><td align="center">数组对象</td></tr><tr><td align="center"></td><td align="center">Math</td><td align="center">数学对象</td></tr><tr><td align="center"></td><td align="center">Date</td><td align="center">日期对象</td></tr><tr><td align="center">高级对象(5个)</td><td align="center">Object</td><td align="center">自定义对象</td></tr><tr><td align="center"></td><td align="center">Error</td><td align="center">错误对象</td></tr><tr><td align="center"></td><td align="center">Runction</td><td align="center">函数对象</td></tr><tr><td align="center"></td><td align="center">RegExp</td><td align="center">正则表达式对象</td></tr><tr><td align="center"></td><td align="center">Global</td><td align="center">全局对象</td></tr></tbody></table><h3 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h3><p>JavaScript的对象（Object）本质上是键值对的集合（Hash结构），但是只能用字符串作为键。</p><pre><code>var a = &#123;&quot;name&quot;: &quot;Alex&quot;, &quot;age&quot;: 18&#125;;console.log(a.name);console.log(a[&quot;age&quot;]);</code></pre><p>遍历对象中的内容：</p><pre><code>var a = &#123;&quot;name&quot;: &quot;Alex&quot;, &quot;age&quot;: 18&#125;;for (var i in a)&#123;  console.log(i, a[i]);&#125;</code></pre><p><a href="https://stackoverflow.com/questions/684672/how-do-i-loop-through-or-enumerate-a-javascript-object">事情并没有那么简单…</a></p><p><strong>创建对象：</strong></p><pre><code>var person=new Object();  // 创建一个person对象person.name=&quot;Alex&quot;;  // person对象的name属性person.age=18;  // person对象的age属性</code></pre><p><em>注意：</em></p><p><em>ES6中提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。</em></p><p><em>也就是说，Object结构提供了“字符串–值”的对应，Map结构提供了“值–值”的对应，是一种更完善的Hash结构实现。</em></p><p> <strong>扩展：</strong></p><pre><code>// 父类构造函数var Car = function (loc) &#123;  this.loc = loc;&#125;;// 父类方法Car.prototype.move = function () &#123;  this.loc ++;&#125;;// 子类构造函数var Van = function (loc) &#123;  Car.call(this, loc);&#125;;// 继承父类的方法Van.prototype = Object.create(Car.prototype);// 修复 constructorVan.prototype.constructor = Van;// 扩展方法Van.prototype.grab = function () &#123;  /* ... */&#125;;</code></pre><h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><h4 id="constructor-属性返回对创建此对象的-Date-函数的引用。"><a href="#constructor-属性返回对创建此对象的-Date-函数的引用。" class="headerlink" title="constructor 属性返回对创建此对象的 Date 函数的引用。"></a>constructor 属性返回对创建此对象的 Date 函数的引用。</h4><p>语法如下</p><pre><code>object.constructor</code></pre><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var test=new Date();if (test.constructor==Array)&#123;document.write(&quot;This is an Array&quot;);&#125;if (test.constructor==Boolean)&#123;document.write(&quot;This is a Boolean&quot;);&#125;if (test.constructor==Date)&#123;document.write(&quot;This is a Date&quot;);&#125;if (test.constructor==String)&#123;document.write(&quot;This is a String&quot;);&#125;&lt;/script&gt;输出结果是: This is a Date</code></pre><h4 id="prototype-使你有能力向对象中添加属性"><a href="#prototype-使你有能力向对象中添加属性" class="headerlink" title="prototype  使你有能力向对象中添加属性"></a>prototype  使你有能力向对象中添加属性</h4><p>语法如下</p><pre><code>object.prototype.name=value</code></pre><pre><code>function employee(name,job,born)&#123;    this.name = name;    this.job = job;    this.born = born;&#125;var bill=new employee(&quot;alex&quot;,&quot;Engineer&quot;,1997);employee.prototype.salary=null;bill.salary=5000;document.write(bill.salary);</code></pre><p><strong>创建Date对象</strong></p><pre><code>//方法1：不指定参数var d1 = new Date();console.log(d1.toLocaleString());//方法2：参数为日期字符串var d2 = new Date(&quot;2004/3/20 11:12&quot;);console.log(d2.toLocaleString());var d3 = new Date(&quot;04/03/20 11:12&quot;);console.log(d3.toLocaleString());//方法3：参数为毫秒数var d3 = new Date(5000);console.log(d3.toLocaleString());console.log(d3.toUTCString());//方法4：参数为年月日小时分钟秒毫秒var d4 = new Date(2004,2,20,11,12,0,300);console.log(d4.toLocaleString());  //毫秒并不直接显示</code></pre><p><strong>Date对象的方法：</strong></p><pre><code>var d = new Date(); //getDate()                 获取日//getDay ()                 获取星期//getMonth ()               获取月（0-11）//getFullYear ()            获取完整年份//getHours ()               获取小时//getMinutes ()             获取分钟//getSeconds ()             获取秒//getMilliseconds ()        获取毫秒//getTime ()                返回累计毫秒数(从1970/1/1午夜)</code></pre><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><pre><code>var str1 = &#39;&#123;&quot;name&quot;: &quot;Alex&quot;, &quot;age&quot;: 18&#125;&#39;;var obj1 = &#123;&quot;name&quot;: &quot;Alex&quot;, &quot;age&quot;: 18&#125;;// JSON字符串转换成对象var obj = JSON.parse(str1); // 对象转换成JSON字符串var str = JSON.stringify(obj1);</code></pre><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test]">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test]</a>: </p><h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><pre><code>//RegExp对象//创建正则对象方式1// 参数1 正则表达式(不能有空格)// 参数2 匹配模式：常用g(全局匹配;找到所有匹配，而不是在第一个匹配后停止)和i(忽略大小写)// 用户名只能是英文字母、数字和_，并且首字母必须是英文字母。长度最短不能少于6位 最长不能超过12位。// 创建RegExp对象方式（逗号后面不要加空格）var reg1 = new RegExp(&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;5,11&#125;$&quot;);// 匹配响应的字符串var s1 = &quot;bc123&quot;;//RegExp对象的test方法，测试一个字符串是否符合对应的正则规则，返回值是true或false。reg1.test(s1);  // true// 创建方式2// /填写正则表达式/匹配模式（逗号后面不要加空格）var reg2 = /^[a-zA-Z][a-zA-Z0-9_]&#123;5,11&#125;$/;reg2.test(s1);  // true// String对象与正则结合的4个方法var s2 = &quot;hello world&quot;;s2.match(/o/g);         // [&quot;o&quot;, &quot;o&quot;]             查找字符串中 符合正则 的内容s2.search(/h/g);        // 0                      查找字符串中符合正则表达式的内容位置s2.split(/o/g);         // [&quot;hell&quot;, &quot; w&quot;, &quot;rld&quot;]  按照正则表达式对字符串进行切割s2.replace(/o/g, &quot;s&quot;);  // &quot;hells wsrld&quot;          对字符串按照正则进行替换// 关于匹配模式：g和i的简单示例var s1 = &quot;name:Alex age:18&quot;;s1.replace(/a/, &quot;哈哈哈&quot;);      // &quot;n哈哈哈me:Alex age:18&quot;s1.replace(/a/g, &quot;哈哈哈&quot;);     // &quot;n哈哈哈me:Alex 哈哈哈ge:18&quot;      全局匹配s1.replace(/a/gi, &quot;哈哈哈&quot;);    // &quot;n哈哈哈me:哈哈哈lex 哈哈哈ge:18&quot;  不区分大小写// 注意事项1：// 如果regExpObject带有全局标志g，test()函数不是从字符串的开头开始查找，而是从属性regExpObject.lastIndex所指定的索引处开始查找。// 该属性值默认为0，所以第一次仍然是从字符串的开头查找。// 当找到一个匹配时，test()函数会将regExpObject.lastIndex的值改为字符串中本次匹配内容的最后一个字符的下一个索引位置。// 当再次执行test()函数时，将会从该索引位置处开始查找，从而找到下一个匹配。// 因此，当我们使用test()函数执行了一次匹配之后，如果想要重新使用test()函数从头开始查找，则需要手动将regExpObject.lastIndex的值重置为 0。// 如果test()函数再也找不到可以匹配的文本时，该函数会自动把regExpObject.lastIndex属性重置为 0。var reg3 = /foo/g;// 此时 regex.lastIndex=0reg3.test(&#39;foo&#39;); // 返回true// 此时 regex.lastIndex=3reg3.test(&#39;xxxfoo&#39;); // 还是返回true// 所以我们在使用test()方法校验一个字符串是否完全匹配时，一定要加上^和$符号。// 注意事项2(说出来你可能不信系列)：// 当我们不加参数调用RegExpObj.test()方法时, 相当于执行RegExpObj.test(&quot;undefined&quot;), 并且/undefined/.test()默认返回true。var reg4 = /^undefined$/;reg4.test(); // 返回truereg4.test(undefined); // 返回truereg4.test(&quot;undefined&quot;); // 返回true</code></pre><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><pre><code>abs(x)      返回数的绝对值。exp(x)      返回 e 的指数。floor(x)    对数进行下舍入。log(x)      返回数的自然对数（底为e）。max(x,y)    返回 x 和 y 中的最高值。min(x,y)    返回 x 和 y 中的最低值。pow(x,y)    返回 x 的 y 次幂。random()    返回 0 ~ 1 之间的随机数。round(x)    把数四舍五入为最接近的整数。sin(x)      返回数的正弦。sqrt(x)     返回数的平方根。tan(x)      返回角的正切。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端HTML</title>
      <link href="/2021/03/22/%E5%89%8D%E7%AB%AFHTML/"/>
      <url>/2021/03/22/%E5%89%8D%E7%AB%AFHTML/</url>
      
        <content type="html"><![CDATA[<h3 id="一-Web服务本质"><a href="#一-Web服务本质" class="headerlink" title="一.Web服务本质"></a>一.Web服务本质</h3><pre><code>import socketsk = socket.socket()sk.bind(&quot;127.0.0.1&quot; , 8888)sk.listen(5)while 1:    conn, addr = sk.accept()    data = conn.recv(9000)    conn.send(b&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)    conn.send(b&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;)    conn.close()</code></pre><h5 id="浏览器发请求–-gt-HTTP协议–-gt-服务端接收请求–-gt-服务端返回响应–-gt-服务端把HTML文件发送给浏览器–-gt-浏览器渲染页面"><a href="#浏览器发请求–-gt-HTTP协议–-gt-服务端接收请求–-gt-服务端返回响应–-gt-服务端把HTML文件发送给浏览器–-gt-浏览器渲染页面" class="headerlink" title="浏览器发请求–&gt;HTTP协议–&gt;服务端接收请求–&gt;服务端返回响应–&gt;服务端把HTML文件发送给浏览器–&gt;浏览器渲染页面"></a>浏览器发请求–&gt;HTTP协议–&gt;服务端接收请求–&gt;服务端返回响应–&gt;服务端把HTML文件发送给浏览器–&gt;浏览器渲染页面</h5><h3 id="二-HTML是什么"><a href="#二-HTML是什么" class="headerlink" title="二.HTML是什么?"></a>二.HTML是什么?</h3><ul><li>超文本标记语言(Hypertext Markup Language , HTML) 是一种创建网页的标记语言</li><li>本质上是浏览器可识别的规则, 我们按照规则写网页, 浏览器根据规则渲染我们的网页,对于不同的浏览器,对用一个标签可能会有不同的解释 (兼容性问题)</li><li>网页文件的扩展名:  .html或.htm</li></ul><h3 id="三-HTML文档结构"><a href="#三-HTML文档结构" class="headerlink" title="三.HTML文档结构"></a>三.HTML文档结构</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;css样式优先级&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li><!DOCTYPE html>声明为HTML5文档 <html>、</html>是文档的开始标记和结束的标记。是HTML页面的根元素，在它们之间是文档的头部（head）和主体（body）。<head>、</head>定义了HTML文档的开头部分。它们之间的内容不会在浏览器的文档窗口显示。包含了文档的元（meta）数据。<title>、</title>定义了网页标题，在浏览器标题栏显示。<body>、</body>之间的文本是可见的网页主体内容。</li></ul><h3 id="四-HTML标签格式"><a href="#四-HTML标签格式" class="headerlink" title="四.HTML标签格式"></a>四.HTML标签格式</h3><ul><li>HTML标签是由尖括号包围的关键字，如 &lt; html &gt; ,  &lt; div&gt;等</li><li>HTML标签通常是成对出现的，比如：&lt; div&gt;和&lt; /div&gt;，第一个标签是开始，第二个标签是结束。结束标签会有斜线。</li><li>也有一部分标签是单独呈现的，比如：&lt; br/&gt;、 &lt; hr/&gt; 、<img src="B:/BLOG/hexoblog/source/_posts/1.jpg" />等。</li><li>标签里面可以有若干属性，也可以不带属性。</li></ul><h5 id="标签的语法"><a href="#标签的语法" class="headerlink" title="标签的语法"></a>标签的语法</h5><ul><li>&lt;标签名 属性1=“属性值1” 属性2=“属性值2”……&gt;内容部分&lt;/标签名&gt;</li><li>&lt;标签名 属性1=“属性值1” 属性2=“属性值2”…… /&gt;</li></ul><h5 id="几个很重要的属性"><a href="#几个很重要的属性" class="headerlink" title="几个很重要的属性"></a>几个很重要的属性</h5><ul><li>id: 定义标签的唯一ID, HTML文档树中唯一</li><li>class: 为html元素定义一个或多个类名(classname) (css样式)</li><li>style:  规定元素的行内样式(css样式)</li></ul><h2 id="五-HTML注释"><a href="#五-HTML注释" class="headerlink" title="五.HTML注释"></a>五.HTML注释</h2><pre><code>&lt;!--注释内容--&gt;</code></pre><h2 id="六-lt-DOCTYPE-gt-标签"><a href="#六-lt-DOCTYPE-gt-标签" class="headerlink" title="六.&lt;!DOCTYPE&gt;标签"></a>六.&lt;!DOCTYPE&gt;标签</h2><!DOCTYPE><p> 声明必须是 HTML 文档的第一行，位于 <html> 标签之前。<br>&lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</p><h2 id="七-HTML常用标签"><a href="#七-HTML常用标签" class="headerlink" title="七.HTML常用标签"></a>七.HTML常用标签</h2><table><thead><tr><th align="center">标签</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">&lt; title&gt;&lt; /title&gt;</td><td align="center">定义网页标题</td></tr><tr><td align="center">&lt; style&gt;&lt; /style&gt;</td><td align="center">定义内部样式表</td></tr><tr><td align="center">&lt; scipt&gt;&lt; /script&gt;</td><td align="center">定义JS代码或引入外部JS文件</td></tr><tr><td align="center">&lt; link/&gt;</td><td align="center">引入外部样式表文件</td></tr><tr><td align="center">&lt; meta/&gt;</td><td align="center">定义网页原信息</td></tr></tbody></table><h5 id="Meta标签"><a href="#Meta标签" class="headerlink" title="Meta标签"></a>Meta标签</h5><p>Meta标签介绍:</p><ul><li><meta>元素可提供有关页面的元信息（mata-information）,针对搜索引擎和更新频度的描述和关键词。</li><li><meta>标签位于文档的头部，不包含任何内容。</li><li><meta>提供的信息是用户不可见的  <p>meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 </p><p>1.http-equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 </p></li></ul><pre><code>&lt;!--2秒后跳转到对应的网址，注意引号--&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2;URL=https://www.oldboyedu.com&quot;&gt;&lt;!--指定文档的编码类型--&gt;&lt;meta http-equiv=&quot;content-Type&quot; charset=UTF8&quot;&gt;&lt;!--告诉IE以最高级模式渲染文档--&gt;&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;</code></pre><p> 2.name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的 </p><pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;meta总结,html meta,meta属性,meta跳转&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;老男孩教育Python学院&quot;&gt;</code></pre><h5 id="body内常用标签"><a href="#body内常用标签" class="headerlink" title="body内常用标签"></a>body内常用标签</h5><p>基本标签 (块级标签和内联标签)</p><pre><code>&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;s&gt;删除&lt;/s&gt;&lt;p&gt;段落标签&lt;/p&gt;&lt;h1&gt;标题1&lt;/h1&gt;&lt;h2&gt;标题2&lt;/h2&gt;&lt;h3&gt;标题3&lt;/h3&gt;&lt;h4&gt;标题4&lt;/h4&gt;&lt;h5&gt;标题5&lt;/h5&gt;&lt;h6&gt;标题6&lt;/h6&gt;&lt;!--换行--&gt;&lt;br&gt;&lt;!--水平线--&gt;&lt;hr&gt;</code></pre><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><table><thead><tr><th align="center">内容</th><th align="center">对应代码</th></tr></thead><tbody><tr><td align="center">空格</td><td align="center">&amp;nbsp ;</td></tr><tr><td align="center">&gt;</td><td align="center">&amp;gt ;</td></tr><tr><td align="center">&lt;</td><td align="center">&amp;lt ;</td></tr><tr><td align="center">&amp;</td><td align="center">&amp;amp ;</td></tr><tr><td align="center">$</td><td align="center">&amp;yen ;</td></tr><tr><td align="center">版权</td><td align="center">&amp;copy ;</td></tr><tr><td align="center">注册</td><td align="center">&amp;reg ;</td></tr></tbody></table><h5 id="div标签和span标签"><a href="#div标签和span标签" class="headerlink" title="div标签和span标签"></a>div标签和span标签</h5><p> div标签用来定义一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。<br>span标签用来定义内联(行内)元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。 </p><p> 块级元素与行内元素的区别：<br>所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。<br>这两个元素是专门为定义CSS样式而生的。 </p><p><strong>注意：</strong></p><p>关于标签嵌套：通常块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。</p><p>p标签不能包含块级标签，p标签也不能包含p标签。</p><h5 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h5><pre><code>&lt;img src=&quot;图片的路径&quot; alt=&quot;图片未加载成功时的提示&quot; title=&quot;鼠标悬浮时提示信息&quot; width=&quot;宽&quot; height=&quot;高(宽高两个属性只用一个会自动等比缩放)&quot;&gt;</code></pre><h5 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h5><p>超链接标签</p><p> 所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。 </p><pre><code>什么是URL？URL是统一资源定位器(Uniform Resource Locator)的缩写，也被称为网页地址，是因特网上标准的资源的地址。URL举例http://www.sohu.com/stu/intro.htmlhttp://222.172.123.33/stu/intro.htmlURL地址由4部分组成第1部分：为协议：http://、ftp://等 第2部分：为站点地址：可以是域名或IP地址第3部分：为页面在站点中的目录：stu第4部分：为页面名称，例如 index.html各部分之间用“/”符号隔开。&lt;a href=&quot;http://www.oldboyedu.com&quot; target=&quot;_blank&quot; &gt;点我&lt;/a&gt;</code></pre><p> href属性指定目标网页地址。该地址可以有几种类型： </p><ul><li>绝对URL - 指向另一个站点（比如 href=”<a href="http://www.jd.com)/">http://www.jd.com）</a></li><li>相对URL - 指当前站点中确切的路径（href=”index.htm”）</li><li>锚URL - 指向页面中的锚（href=”#top”）</li></ul><p>target:</p><ul><li>_blank表示在新标签页中打开目标网页</li><li>_self表示在当前标签页中打开目标网页</li></ul><h2 id="八-列表"><a href="#八-列表" class="headerlink" title="八.列表"></a>八.列表</h2><p>1.无序列表</p><pre><code>&lt;ul type=&quot;disc&quot;&gt;  &lt;li&gt;第一项&lt;/li&gt;  &lt;li&gt;第二项&lt;/li&gt;&lt;/ul&gt;</code></pre><p>type属性:</p><ul><li>disc(实心原点,默认值)</li><li>circle(空心圆圈)</li><li>square(实心方块)</li><li>none(无样式)</li></ul><p>2.有序列表</p><pre><code>&lt;ol type=&quot;1&quot; start=&quot;2&quot;&gt;  &lt;li&gt;第一项&lt;/li&gt;  &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt;</code></pre><p>type属性:</p><ul><li>1 数字列表, 默认值</li><li>A 大写字母</li><li>a 小写字母</li><li>I 大写罗马</li><li>i 小写罗马</li></ul><p>3.标题列表</p><pre><code>&lt;dl&gt;  &lt;dt&gt;标题1&lt;/dt&gt;  &lt;dd&gt;内容1&lt;/dd&gt;  &lt;dt&gt;标题2&lt;/dt&gt;  &lt;dd&gt;内容1&lt;/dd&gt;  &lt;dd&gt;内容2&lt;/dd&gt;&lt;/dl&gt;</code></pre><h2 id="九-表格"><a href="#九-表格" class="headerlink" title="九.表格"></a>九.表格</h2><p> 表格是一个二维数据空间，一个表格由若干行组成，一个行又有若干单元格组成，单元格里可以包含文字、列表、图案、表单、数字符号、预置文本和其它的表格等内容。<br>表格最重要的目的是显示表格类数据。表格类数据是指最适合组织为表格格式（即按行和列组织）的数据。<br>表格的基本结构： </p><pre><code>&lt;table&gt;  &lt;thead&gt;  &lt;tr&gt;    &lt;th&gt;序号&lt;/th&gt;    &lt;th&gt;姓名&lt;/th&gt;    &lt;th&gt;爱好&lt;/th&gt;  &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;tr&gt;    &lt;td&gt;1&lt;/td&gt;    &lt;td&gt;Egon&lt;/td&gt;    &lt;td&gt;杠娘&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;2&lt;/td&gt;    &lt;td&gt;Yuan&lt;/td&gt;    &lt;td&gt;日天&lt;/td&gt;  &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;</code></pre><p>属性:</p><ul><li>border: 表格边框</li><li>cellpadding: 内边距</li><li>cellspacing: 外边距</li><li>width: 像素 百分比. (最好通过css来设置长宽)</li><li>rowspan: 单元格竖跨多少行</li><li>colspan: 单元格横跨多少列(即合并单元格)</li></ul><h2 id="十-form"><a href="#十-form" class="headerlink" title="十.form"></a>十.form</h2><p>功能:</p><p>表单用于向服务器传输数据，从而实现用户与Web服务器的交互</p><p>表单能够包含input系列标签，比如文本字段、复选框、单选框、提交按钮等等。</p><p>表单还可以包含textarea、select、fieldset和 label标签。</p><p>表单属性</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">accept-charset</td><td align="center">规定在被提交表单中使用的字符集（默认：页面字符集)</td></tr><tr><td align="center">action</td><td align="center">规定向何处提交表单的地址(URL) (提交页面)</td></tr><tr><td align="center">autocomplete</td><td align="center">规定浏览应该自动完成表单(默认:  开启)</td></tr><tr><td align="center">enctype</td><td align="center">规定被提交数据的编码 (默认: url-encoded)</td></tr><tr><td align="center">method</td><td align="center">规定在提交表单时所用的HTTP方法 (默认: GET)</td></tr><tr><td align="center">name</td><td align="center">规定识别表单的名称 (对于DOM使用: document.forms.name)</td></tr><tr><td align="center">novalidate</td><td align="center">规定浏览器不验证表单</td></tr><tr><td align="center">target</td><td align="center">规定 action 属性中地址的目标 (默认: _self)</td></tr></tbody></table><h5 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h5><p> 基本概念：<br>HTML表单是HTML元素中较为复杂的部分，表单往往和脚本、动态页面、数据处理等功能相结合，因此它是制作动态网站很重要的内容。<br>表单一般用来收集用户的输入信息<br>表单工作原理：<br>访问者在浏览有表单的网页时，可填写必需的信息，然后按某个按钮提交。这些信息通过Internet传送到服务器上。<br>服务器上专门的程序对这些数据进行处理，如果有错误会返回错误信息，并要求纠正错误。当数据完整无误后，服务 器反馈一个输入完成的信息</p><pre><code>from django.conf.urls import urlfrom django.shortcuts import HttpResponsedef upload(request):    print(&quot;request.GET:&quot;, request.GET)    print(&quot;request.POST:&quot;, request.POST)    if request.FILES:        filename = request.FILES[&quot;file&quot;].name        with open(filename, &#39;wb&#39;) as f:            for chunk in request.FILES[&#39;file&#39;].chunks():                f.write(chunk)            return HttpResponse(&#39;上传成功&#39;)    return HttpResponse(&quot;收到了！&quot;)urlpatterns = [    url(r&#39;^upload/&#39;, upload),]Django接收上传文件代码</code></pre><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p><input> 元素会根据不同的 type 属性，变化为多种形态。</p><table><thead><tr><th>type属性值</th><th>表现形式</th><th>对应代码</th></tr></thead><tbody><tr><td>text</td><td>单行输入文本</td><td>&lt;input type=text” /&gt;</td></tr><tr><td>password</td><td>密码输入框</td><td><input type="password" /></td></tr><tr><td>date</td><td>日期输入框</td><td><input type="date" /></td></tr><tr><td>checkbox</td><td>复选框</td><td><input type="checkbox" checked="checked" /></td></tr><tr><td>radio</td><td>单选框</td><td><input type="radio" /></td></tr><tr><td>submit</td><td>提交按钮</td><td><input type="submit" value="提交" /></td></tr><tr><td>reset</td><td>重置按钮</td><td><input type="reset" value="重置" /></td></tr><tr><td>button</td><td>普通按钮</td><td><input type="button" value="普通按钮" /></td></tr><tr><td>hidden</td><td>隐藏输入框</td><td><input type="hidden" /></td></tr><tr><td>file</td><td>文本选择框</td><td><input type="file" /></td></tr></tbody></table><p> 属性说明:</p><ul><li>name：表单提交时的“键”，注意和id的区别</li><li>value：表单提交时对应项的值<ul><li>type=”button”, “reset”, “submit”时，为按钮上显示的文本年内容</li><li>type=”text”,”password”,”hidden”时，为输入框的初始值</li><li>type=”checkbox”, “radio”, “file”，为输入相关联的值</li></ul></li><li>checked：radio和checkbox默认被选中的项</li><li>readonly：text和password设置只读</li><li>disabled：所有input均适用</li></ul><h3 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;  &lt;select name=&quot;city&quot; id=&quot;city&quot;&gt;    &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;    &lt;option selected=&quot;selected&quot; value=&quot;2&quot;&gt;上海&lt;/option&gt;    &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt;    &lt;option value=&quot;4&quot;&gt;深圳&lt;/option&gt;  &lt;/select&gt;&lt;/form&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>属性说明：</p><ul><li>multiple：布尔属性，设置后为多选，否则默认单选</li><li>disabled：禁用</li><li>selected：默认选中该项</li><li>value：定义提交时的选项值</li></ul><h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><p>定义：<label> 标签为 input 元素定义标注（标记）。<br>说明：</p><ol><li>label 元素不会向用户呈现任何特殊效果。</li><li><label> 标签的 for 属性值应当与相关元素的 id 属性值相同。</li></ol><pre><code>&lt;form action=&quot;&quot;&gt;  &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;  &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;&lt;/form&gt;</code></pre><h3 id="textarea多行文本"><a href="#textarea多行文本" class="headerlink" title="textarea多行文本"></a>textarea多行文本</h3><pre><code>&lt;textarea name=&quot;memo&quot; id=&quot;memo&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;  默认内容&lt;/textarea&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程_并发编程</title>
      <link href="/2021/02/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/02/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="一-操作系统理论"><a href="#一-操作系统理论" class="headerlink" title="一.操作系统理论"></a>一.操作系统理论</h3><ul><li><p>计算机的硬件组成</p><ul><li>主板    固化(寄存器, 是直接和cpu进行交互的一个硬件)</li><li>cpu     中央处理器: 计算  (数字计算和逻辑计算) 和控制 (控制所有硬件协调工作)</li><li>存储    硬盘, 内存</li><li>输入设备  键盘, 鼠标, 话筒</li><li>输出设备  显示器, 音箱, 打印机<ul><li>早期的计算机是以计算为核心的</li><li>现在的计算机是以存储为核心的</li></ul></li><li>第一代计算机:  电子管计算机, 及其耗电, 体积庞大, 散热量特别高</li><li>第二代计算机:  晶体管计算机</li><li>第三代计算机:  白色大头计算机, 集成电路计算机. 一个板子固化几十到上百个小硬件</li><li>第四代计算机:  大型集成电路计算机, 一个板子可以达到固化十万个硬件</li><li>第五代计算机: 甚大型集成电路计算机</li></ul></li><li><p>计算机的操作系统</p><ul><li>操作系统是一个软件, 是一个能直接操纵硬件的一个软件,微软研发的windows系统</li><li>人工时代: 穿孔卡带, 每个人都能在一段时间内独享计算机所有资源</li><li>脱机时代:  完全将人和及其隔离开来</li><li>单道批处理系统:  内存中允许存放一道作业</li><li>多道批处理系统:  内存中允许存放多道作业</li><li>分时系统:  将cpu和执行划分时间片, 每个程序以时间片为单位去执行</li><li>实时系统:  一般比较少见, 主要用于军事和工业生产上</li><li>操作系统的目的: 让用户用起来更加轻松, 高可用, 低耦合</li></ul></li><li><p>语言的发展史</p><ul><li>计算机识别的二进制, 机器语言, 由0 和  1  组成代码<ul><li>汇编语言, add ,n,m</li><li>高级语言:  面向过程(C)    面向对象语言(C++, java, python, php)</li></ul></li><li>os(操作系统)<ul><li>dos系统    纯编程系统    单用户单任务</li><li>windows系统      单用户多任务(早期的windows)</li><li>unix系统    多用户多任务</li></ul></li></ul></li><li><p>操作系统的作用</p><ul><li>封装所有硬件接口, 让各种用户使用电脑更加轻松</li><li>是对计算机内所有资源进行合理的调度和分配</li></ul></li></ul><h2 id="二-进程"><a href="#二-进程" class="headerlink" title="二.进程"></a>二.进程</h2><ul><li>进程的理论<ul><li>.sh  shell脚本文件</li><li>.out linux系统中的可执行文件</li><li>.bat 批处理脚本文件</li><li>.lib  库文件</li><li>.dll 库文件</li><li>.exe 可执行文件, 双击能直接运行的文件</li></ul></li><li>进程<ul><li>是指正在执行的程序,是程序执行过程中的一次 指令, 数据集等的集合</li><li>也可以叫做程序的一次执行过程</li><li>进程是一个动态的概念</li></ul></li><li>进程由三大部分组成:  代码段,  数据段,  PCB:  进程管理控制</li><li>进程的三大基本状态:<ul><li>就绪状态:  已经获得运行需要的所有资源, 处理cpu</li><li>执行状态:  已经获得了所有的资源包括cpu, 处于正在运行</li><li>阻塞状态:  因为各种原因, 进程放弃了cpu, 导致进程无法继续执行,此时进程处于内存中,继续等待获取cpu</li></ul></li><li>进程的一个特殊状态<ul><li>挂起状态:  是指因为各种原因,进程放弃了cpu, 导致进程无法继续执行,此时进程被踢出内存</li></ul></li><li>multiprocessing 内置模块, 是python提供, 主要用于多线程编程</li></ul><h2 id="三-多进程"><a href="#三-多进程" class="headerlink" title="三.多进程"></a>三.多进程</h2><h5 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1.名词解释"></a>1.名词解释</h5><ul><li><h6 id="同步和异步关注的是消息通信机制"><a href="#同步和异步关注的是消息通信机制" class="headerlink" title="同步和异步关注的是消息通信机制"></a>同步和异步关注的是消息通信机制</h6></li><li><p>并行: 并行是指两者同时执行, 比如有两条车道,在某一时间点, 两条车道上都有车在跑(资源够用,比如三个线程, 四核的CPU) 指两件或多件事在同一时间点执行</p></li><li><p>并发: 指两件或多件事在同一时间间隔同时执行</p><ul><li><p>区别: 并行是从微观上,也就是在一个精确的时间片刻,有不同的程序在执行, 这就要求必须有多个处理器</p><p>并发是从宏观上,在一个时间段上可以看出是同时执行的, 比如一个服务器同时处理多个session</p></li><li><p>早起单核CPU时候, 对于进程也是微观上串行(站在cpu角度看), 宏观上并行(站在人的角度看就是同时有很多程序执行)</p></li></ul></li><li><h6 id="同步-所谓同步就是一个任务的完成需要依赖另外一个任务时-只有等待被依赖的任务完成时-依赖的任务才能算完成-这是一种可靠的任务序列-要么都成功-要么都失败-两个任务的状态可以保持一致"><a href="#同步-所谓同步就是一个任务的完成需要依赖另外一个任务时-只有等待被依赖的任务完成时-依赖的任务才能算完成-这是一种可靠的任务序列-要么都成功-要么都失败-两个任务的状态可以保持一致" class="headerlink" title="同步: 所谓同步就是一个任务的完成需要依赖另外一个任务时, 只有等待被依赖的任务完成时,依赖的任务才能算完成,这是一种可靠的任务序列.要么都成功. 要么都失败, 两个任务的状态可以保持一致"></a>同步: 所谓同步就是一个任务的完成需要依赖另外一个任务时, 只有等待被依赖的任务完成时,依赖的任务才能算完成,这是一种可靠的任务序列.要么都成功. 要么都失败, 两个任务的状态可以保持一致</h6></li><li><h6 id="异步-所谓异步是不需要等待依赖的任务完成-只是通知被依赖的任务要完成什么工作-依赖的任务也立即执行-只要自己完成了整个任务就算完成了-至于被依赖的任务最重是否真正完成-依赖它的任务无法确定-所以它是不可靠任务序列"><a href="#异步-所谓异步是不需要等待依赖的任务完成-只是通知被依赖的任务要完成什么工作-依赖的任务也立即执行-只要自己完成了整个任务就算完成了-至于被依赖的任务最重是否真正完成-依赖它的任务无法确定-所以它是不可靠任务序列" class="headerlink" title="异步: 所谓异步是不需要等待依赖的任务完成, 只是通知被依赖的任务要完成什么工作, 依赖的任务也立即执行, 只要自己完成了整个任务就算完成了, 至于被依赖的任务最重是否真正完成, 依赖它的任务无法确定, 所以它是不可靠任务序列"></a>异步: 所谓异步是不需要等待依赖的任务完成, 只是通知被依赖的任务要完成什么工作, 依赖的任务也立即执行, 只要自己完成了整个任务就算完成了, 至于被依赖的任务最重是否真正完成, 依赖它的任务无法确定, 所以它是不可靠任务序列</h6></li><li><p>阻塞: 阻塞是当请求不能满足的时候将进程挂起</p></li><li><p>非阻塞: 非阻塞是不会阻塞当前进程,非阻塞调用指在不能立刻得到结果之前也会立刻返回，同时该函数不会阻塞当前线程。</p></li><li><h6 id="阻塞和非阻塞针对的是进程或线程"><a href="#阻塞和非阻塞针对的是进程或线程" class="headerlink" title="阻塞和非阻塞针对的是进程或线程"></a>阻塞和非阻塞针对的是进程或线程</h6></li></ul><h5 id="2-进程的两种开启方法"><a href="#2-进程的两种开启方法" class="headerlink" title="2.进程的两种开启方法"></a>2.进程的两种开启方法</h5><p>(1) p = Process(target = func, args (,))</p><pre><code>from multiprocessing import Processimport timeimport osdef func(i):    time.sleep(1)    print(&#39;这里是%s儿子进程%s,父进程是%s&#39; % (i, os.getpid(), os.getppid()))if __name__ == &#39;__main__&#39;:    for i in range(2):        p = Process(target=func, args=(i,))        p.start()    print(&#39;这里是父亲进程%s&#39; % (os.getpid()))</code></pre><p>(2)  自定义类, 继承Process类</p><pre><code># 自定义类继承Processclass MyProcess(Process):    def __init__(self):        self.name = name        super(MyProcess, self).__init__(name=self.name)  # 实现父类的__init__方法    def run(self):        print(&#39;这是以继承的方式开启子进程%s&#39; % self.name)if __name__ == &#39;__main__&#39;:    name = &#39;alex&#39;    p1 = MyProcess()    p1.start()  # 是指解释器告诉操作系统, 去帮我开启一个进程, 属于就绪状态    # p1.run()  # 告诉操作系统,现在马上执行这个子进程, 属于执行状态</code></pre><h5 id="3-如何开启多个不同的子进程"><a href="#3-如何开启多个不同的子进程" class="headerlink" title="3.如何开启多个不同的子进程"></a>3.如何开启多个不同的子进程</h5><pre><code>#  开启多个子进程def func(i):    time.sleep(1)    print(&#39;这是第%s个子进程,进程id是%s&#39; % (i, os.getpid()))if __name__ == &#39;__main__&#39;:    for i in range(10):        p = Process(target=func, args=(i,))        p.start()    print(&#39;父进程的ID是%s&#39; % os.getpid())</code></pre><h5 id="4-进程的常用方法-start-join-terminate-is-alive"><a href="#4-进程的常用方法-start-join-terminate-is-alive" class="headerlink" title="4.进程的常用方法(start. join,terminate, is_alive)"></a>4.进程的常用方法(start. join,terminate, is_alive)</h5><pre><code>from multiprocessing import Processimport timedef func():    for i in range(10):        time.sleep(0.1)        print(&#39;儿子在这里&#39;)if __name__ == &#39;__main__&#39;:    p = Process(target=func)    p.start()    p.join()  # 当程序执行到这一句话时, 主进程开始阻塞. 等待子进程执行完    for i in range(10):        time.sleep(0.1)        print(&#39;爸爸在这里&#39;)#  开启一个正常的子进程, 父进程会等待子进程结束后, 父进程也就是程序才结束#  p.join() 是主进程等待子进程执行完.  现象:  主进程执行到这句话时,主进程阻塞主,等待子进程执行def func():    time.sleep(1)    print(123)if __name__ == &#39;__main__&#39;:    p = Process(target=func)    p.start()    p.terminate()  #  杀死p进程, 让解释器告诉操作系统, 请杀死p进程    print(&#39;子进程是否活着?&#39;, p.is_alive())    print(&#39;父进程id%s&#39;% os.getpid())    time.sleep(0.01)    print(&#39;子进程是否活着?&#39;, p.is_alive())    #  返回一个bool值, 如果返回True. 代表进程还活着, 如果返回False, 代表子进程死了#  p.is_alive() 判断p进程是否还活着#  p.terminate() 杀死p进程</code></pre><ul><li>如何把父进程和子进程之间的关系变为同步或者异步?<ul><li>父进程执行join, 就会变成同步, 不执行join. 父进程和子进程的关系就是异步的关系</li><li>join必须放在start() 后边</li></ul></li></ul><h5 id="5-多个子进程"><a href="#5-多个子进程" class="headerlink" title="5.多个子进程"></a>5.多个子进程</h5><pre><code>from multiprocessing import Processimport timeimport randomdef func(i):    print(&#39;我是%s&#39; % i)if __name__ == &#39;__main__&#39;:    l = []    addr = [&#39;上海的&#39;, &#39;河南的&#39;, &#39;北京的&#39;]    for i in addr:        p = Process(target=func, args=(i,))        p.start()        l.append(p)    [p.join() for p in l]  # 列表推导式    time.sleep(1)    print(&#39;我选%s&#39; % (random.choice(addr)))</code></pre><h5 id="6-进程的常用属性"><a href="#6-进程的常用属性" class="headerlink" title="6.进程的常用属性"></a>6.进程的常用属性</h5><ul><li>p.name = 给p进程一个名字</li><li>p.pid      返回p进程的pid</li><li>p.daemon = True   将p进程蛇者为守护进程,(True为守护进程, False 为普通进程)<ul><li>守护进程的两个特点:<ul><li>守护进程会随着父进程的结束而结束</li><li>守护进程不能再创建子进程</li></ul></li></ul></li></ul><h2 id="四-队列-管道-回调函数"><a href="#四-队列-管道-回调函数" class="headerlink" title="四.队列,管道,回调函数"></a>四.队列,管道,回调函数</h2><h5 id="1-生产者消费者模型"><a href="#1-生产者消费者模型" class="headerlink" title="1.生产者消费者模型"></a>1.生产者消费者模型</h5><ul><li>主要是为了解耦</li><li>借助队列来实现生产者消费者模型<ul><li>栈:  先进后出(First In Last Out   简称 FILO)</li><li>队列:  先进先出(First In First Out   简称FIFO)</li></ul></li></ul><pre><code>import queue # 不能进行多进程之间的数据传输(1) from multiprocessing import Queue  借助Queue来解决生产者消费者模型    队列是安全的    q = Queue(num) 实例化    num:  队列的最大长度    q.get()  # 阻塞等待获取数据,如果有数据直接获取, 如果没有数据,阻塞等待    q.put()  # 阻塞, 如果可以继续往队列中放数据,就直接放, 不能放就直接阻塞等待    q.get_nowait()  # 不阻塞,如果有数据直接获取, 没有数据直接就报错    q.put_nowait()  # 不阻塞,如果可以继续往队列中放数据, 就直接方放, 不能放就报错(2) from multiprocessing import joinableQueue # 可连接队列    joinableQueue 是继承Queue,    并且joinableQueue多了两个方法    q.join()  # 用于生产者 等待q.task_done的返回结果, 通过返回结果,生产者就能获取当前消费者消费了多少数据    q.task_done()  # 用于消费者, 是指每消费队列中一个数据, 九个join返回一个标识</code></pre><ul><li><h5 id="队列实现生产者消费者模型"><a href="#队列实现生产者消费者模型" class="headerlink" title="队列实现生产者消费者模型"></a>队列实现生产者消费者模型</h5><pre><code>from multiprocessing import Process, Queueimport time</code></pre></li></ul><p>  def consumer(q, name, color):<br>      while 1:<br>          info = q.get()<br>          if info:<br>              print(‘%s %s 拿走了%s \033[0m’ % (color, name, info))<br>          else:<br>              break</p><p>  def producer(q, product):<br>      for i in range(20):<br>          q.put(product + ‘的娃娃%s’ % str(i))</p><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:<br>      q = Queue(10)<br>      p_con1 = Process(target=producer, args=(q, ‘贝贝’))<br>      p_con2 = Process(target=producer, args=(q, ‘吉吉’))<br>      p_con3 = Process(target=producer, args=(q, ‘果果’))<br>      p_pro1 = Process(target=consumer, args=(q, ‘alex’, ‘\033[31m’))<br>      p_pro2 = Process(target=consumer, args=(q, ‘wusir’, ‘\033[32m’))<br>      l = [p_con1, p_con2, p_con3, p_pro1, p_pro2]<br>      [p.start() for p in l]<br>      #  父进程如何感知生产者子进程不再生产数据了?<br>      p_con1.join()<br>      p_con2.join()<br>      p_con3.join()<br>      q.put(None)  # 几个消费者就要接受几个结束标识<br>      q.put(None)</p><pre><code>- joinableQueue新模块</code></pre><p>rom multiprocessing import Process, JoinableQueue, Queue</p><p>def consumer(q, name, color):<br>    while 1:<br>        info = q.get()<br>        print(‘%s %s 拿走了%s’ % (color, name, info))<br>        q.task_done()</p><p>def producer(q, product):<br>    for i in range(20):<br>        q.put(product + ‘的娃娃%s号 \033[0m’ % str(i))<br>    q.join()</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    q = JoinableQueue(10)<br>    p_con = Process(target=consumer, args=(q, ‘alex’, ‘\033[31m’))<br>    p_pro = Process(target=producer, args=(q, ‘果果’))<br>    p_con.daemon = True<br>    p_con.start()<br>    p_pro.start()<br>    p_pro.join()  # 主进程等待生产者进程结束<br>    # 程序有3个进程，主进程和生产者进程和消费者进程。  当主进程执行到35行代码时，主进程会等待生产进程结束<br>    # 而生产进程中（第26行）会等待消费者进程把所有数据消费完，生产者进程才结束。<br>    # 现在的状态就是  主进程等待生产者进程结束，生产者进程等待消费者消费完所有数据<br>    # 所以，把消费者设置为守护进程。  当主进程执行完，就代表生产进程已经结束，也就代表消费者进程已经把队列中数据消费完<br>    # 此时，主进程一旦结束，守护进程也就是消费者进程也就跟着结束。    整个程序也就能正常结束了。</p><pre><code>- Manger</code></pre><p>from multiprocessing import Process, Manager</p><p>def func(num):<br>    num[0] -= 1<br>    print(‘子进程找中的num值是’, num)</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    m = Manager()<br>    num = m.list([1,2,3])<br>    p = Process(target=func, args=(num,))<br>    p.start()<br>    p.join()<br>    print(‘父进程中的num值是’, num)</p><pre><code>- 管道使用</code></pre><h1 id="单进程管道的使用"><a href="#单进程管道的使用" class="headerlink" title="单进程管道的使用"></a>单进程管道的使用</h1><p>from multiprocessing import Pipe</p><p>con1, con2 = Pipe()</p><p>con1.send(‘123’)<br>print(con2.recv())<br>con2.send(‘abd’)<br>print(con1.recv())</p><h1 id="多进程管道的使用"><a href="#多进程管道的使用" class="headerlink" title="多进程管道的使用"></a>多进程管道的使用</h1><p>from multiprocessing import Process, Pipe</p><p>def func(con):<br>    con1, con2 = con<br>    con1.close()<br>    while 1:<br>        try:</p><pre><code>        print(con2.recv())    except EOFError:        con2.close()        break</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    con1, con2 = Pipe()<br>    p = Process(target=func, args=((con1, con2),))<br>    p.start()<br>    con2.close()  # 在父进程中, 使用con1 和 子进程通信, 所以不需要con2<br>    for i in range(10):  # 生产数据<br>        con1.send(i)  # 给子进程con2发送数据<br>    con1.close()  # 生产完数据, 关闭父进程这一端的管道</p><pre><code>- 进程池和多进程效率对比</code></pre><p>from multiprocessing import Pool, Process<br>import os<br>import time</p><p>def func(num):<br>    num += 1<br>    print(num)</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    p = Pool(os.cpu_count() + 1)<br>    start = time.time()<br>    p.map(func, [i for i in range(100)])<br>    p.close()  # 值不允许向进程池中添加任务<br>    p.join()  # 等待进程池中所有进程执行完任务<br>    print(‘进程池做任务的效率’, time.time() - start)</p><pre><code>start = time.time()p_l = []for i in range(100):    p1 = Process(target=func, args=(i,))    p1.start()    p_l.append(p1)[p1.join() for p1 in p_l]print(&#39;多进程做任务的效率&#39;, time.time() - start)</code></pre><pre><code></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结</title>
      <link href="/2020/12/01/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2020/12/01/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-遍历字典"><a href="#1-遍历字典" class="headerlink" title="1.遍历字典"></a>1.遍历字典</h3><pre><code>for k,v in dic.items()</code></pre><h3 id="2-什么叫闭包"><a href="#2-什么叫闭包" class="headerlink" title="2.什么叫闭包?"></a>2.什么叫闭包?</h3><p>函数内部调用函数外部(局部)的变量</p><h3 id="3-在调用一个函数中-如何结束本程序"><a href="#3-在调用一个函数中-如何结束本程序" class="headerlink" title="3.在调用一个函数中,如何结束本程序?"></a>3.在调用一个函数中,如何结束本程序?</h3><pre><code>quit() sys.exit() exit() 让函数抛出异常</code></pre><h3 id="4-交换机和路由器的区别"><a href="#4-交换机和路由器的区别" class="headerlink" title="4.交换机和路由器的区别?"></a>4.交换机和路由器的区别?</h3><p>交换机的主要功能是组织局域网, 经过交换机内部处理解析信息之后, 将信息以点对点,点对多的形式传给固定端</p><p>路由器: 跨网段进行数据传输,路由选择最佳路径</p><h3 id="5-针对-使用UDP协议发送数据-一次收发大小究竟多少合适"><a href="#5-针对-使用UDP协议发送数据-一次收发大小究竟多少合适" class="headerlink" title="5.针对 使用UDP协议发送数据,一次收发大小究竟多少合适?"></a>5.针对 使用UDP协议发送数据,一次收发大小究竟多少合适?</h3><p>udp不会发生粘包,udp协议本层对一次收发数据大小的限制是:</p><p>​    65535 - ip包头(20) - udp包头(8) = 65507</p><p>站在数据链路层, 因为网卡的MTU 一般被限制在了1500, 所以对数据链路层来说,一次收发数据的大小被限制在</p><p>​    1500 - ip包头(20) - udp包头(8) = 1472</p><p>得到结论:</p><p>​    如果sendto(num)</p><p>​    num &gt; 65507 就会报错</p><p>​    1472 &lt; num &lt; 65507 会在数据链路层拆包,而udp本身就是不可靠协议, 所以一旦</p><p>拆包之后, 造成的多个小数据包在网络传输中,如果丢任何一个, 那么此次数据传输就会失败</p><p>​    num &lt; 1472 是比较理想的状态</p><h4 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6.面试题"></a>6.面试题</h4><pre><code>&quot;&quot;&quot;编写Python脚本，分析xx.log文件，按域名统计访问次数xx.log文件内容如下：https://www.sogo.com/ale.htmlhttps://www.qq.com/3asd.htmlhttps://www.sogo.com/teoans.htmlhttps://www.bilibili.com/2https://www.sogo.com/asd_sa.htmlhttps://y.qq.com/https://www.bilibili.com/1https://dig.chouti.com/https://www.bilibili.com/imd.htmlhttps://www.bilibili.com/脚本输出：4 www.bilibili.com3 www.sogo.com1 www.qq.com1 y.qq.com1 dig.chouti.com&quot;&quot;&quot;import refrom collections import Counterwith open(&quot;xx.log&quot;) as f:    data = f.read()ym_list = re.findall(r&#39;https://(.*?)/.*?&#39;, data)ym_dict = dict(Counter(ym_list))ret = sorted(ym_dict.items(), key=lambda x: x[1], reverse=True)print(ret)for i in ret:    print(i[1], i[0])</code></pre><pre><code>1. 谈谈你对面向对象的理解？对象 = 数据 + 方法2. Python面向对象中的继承有什么特点？继承的优点：　　1、建造系统中的类，避免重复操作。　　2、新类经常是基于已经存在的类，这样就可以提升代码的复用程度。继承的特点：　　1、在继承中基类的构造（__init__()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。有别于C#　　2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数　　3、Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。3. 面向对象深度优先和广度优先是什么？必须得了解：MRO深度优先 广度优先 C3算法  =&gt; http://python.jobbole.com/85685/4. 面向对象中super的作用？    在子类中执行父类的方法5. 列举面向对象中特殊成员(带双下划线的特殊方法，如：__new__、__init__、__call__等)    __new__(): 开辟空间，创建对象    __init__(): 初始化对象，对象属性的赋值    __call__(): 对象()直接执行的代码    __str__(): print(对象)时执行的    __repr__(): 解释器环境下直接输入对象展示的内容    __len__(): len()    __del__(): 析构    __hash__():    __eq__():    __setitem__():    __getitem__():    __delitem__():6. 静态方法和类方法区别？    顾名思义，类方法就是Python类的方法，是这个类可以调用的方法，那么参数需要把这个类本身传进去，不需要实例化就可以使用。静态方法是类中的一个普通函数或者说方法，那么参数和普通的传参一样，类或者实例化的对象都可以直接使用它，也就是说这个静态方法也不需要实例化就可以调用。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2020/11/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/11/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="一-网络基础"><a href="#一-网络基础" class="headerlink" title="一.网络基础"></a>一.网络基础</h3><p>​    1.网络基础相关的知识</p><p>​        (1) 架构</p><p>​            a. C/S 架构 : client 客户端 和  server 服务器端</p><p>​                优势: 能充分发挥PC机的性能</p><p>​            b. B/S 架构 : browser 浏览器  和 server 服务器端</p><p>​                优点 : 统一了应用的接口</p><p>​        (2)通信</p><p>​            a. 同一台电脑上两个程序通信 :  打开一个文件</p><p>​            b. 两个电脑如何通信 :  连一个网线</p><p>​            c. 多个电脑通信:</p><p>​                 ex : 电脑1(源)要找电脑2(目标)</p><pre><code>             电脑1首先发送一个请求帧,期中包含(我的ip是192.168.1.1,我的mac地址是xxxxxxxx,我要找ip地址为192.168.1.2的主机),将此请求发送给交换机.             交换机要广播这条消息给其他所有的主机             目标主机接收到消息后,对比发现自己就是被找的主机,回复给交换机信息(我的ip地址是192.168.1.2,我的mac地址是yyyyyyyyy,请回复给ip地址为192.168.1.1,mac地址为xxxxxxx的主机)             交换机单播形式返回给源主机</code></pre><p>​        </p><p>​    2.mac地址: 是一个物理地址,全球唯一, 类似于身份证</p><p>​    3.ip地址 : 是一个四位点分十进制,它标识了计算机在网络中的位置</p><p>​    4.交换机的通信方式:</p><p>​        广播: 吼一嗓子</p><p>​        单播 : 一对一</p><p>​        组播 : 一对多</p><h6 id="5-arp协议-通过目标ip地址获取目标mac地址的一个协议"><a href="#5-arp协议-通过目标ip地址获取目标mac地址的一个协议" class="headerlink" title="5.arp协议 : 通过目标ip地址获取目标mac地址的一个协议"></a>5.arp协议 : 通过目标ip地址获取目标mac地址的一个协议</h6><p>​    6.端口 : 操作系统位本机每一运行的程序都随机分配一个端口, 其他电脑上的程序可以通过端口来获取到这个程序        (ip地址 + 端口  能唯一找到某台电脑上的某一个服务程序)(0-65535 0-1023不能用)</p><p>​    7.网段 : 一个局域网内 ip 地址的范围</p><p>​    8.子网掩码 : 用来计算网段的, 子网掩码  &amp;  ip 地址 获取网段</p><p>​    9.arp协议 : 同过目标ip地址获取目标mac 地址的一个协议</p><h3 id="二-socket模块"><a href="#二-socket模块" class="headerlink" title="二.socket模块"></a>二.socket模块</h3><h4 id="一-OSI-五层模型"><a href="#一-OSI-五层模型" class="headerlink" title="一.OSI 五层模型 :"></a>一.OSI 五层模型 :</h4><p>​            1.应用层                                    http,https,ftp</p><p>​            2.传输层    四层交换机,四层路由器    UDP和 TCP</p><p>​            3.网络层    路由器,以太网交换机    IP协议</p><p>​            4.数据链路层    交换机,网卡,网桥    arp协议</p><p>​            5.物理层    光纤,集成器,网线             </p><h4 id="二-socket模块-1"><a href="#二-socket模块-1" class="headerlink" title="二.socket模块"></a>二.socket模块</h4><h6 id="TCP协议-面向连接-可靠的-面向字节流形式的"><a href="#TCP协议-面向连接-可靠的-面向字节流形式的" class="headerlink" title="TCP协议    面向连接,可靠的,面向字节流形式的"></a>TCP协议    面向连接,可靠的,面向字节流形式的</h6><h6 id="UDP协议-无连接的-不可靠-面向数据报形式的-传输速度快"><a href="#UDP协议-无连接的-不可靠-面向数据报形式的-传输速度快" class="headerlink" title="UDP协议    无连接的,不可靠,面向数据报形式的,传输速度快"></a>UDP协议    无连接的,不可靠,面向数据报形式的,传输速度快</h6><h6 id="1-交换价和路由器的区别"><a href="#1-交换价和路由器的区别" class="headerlink" title="1.交换价和路由器的区别?"></a>1.交换价和路由器的区别?</h6><p>​    交换机的主要功能是组织局域网,经过交换机内部处理解析信息之后,将信息以点对点,点对多的形式,发送给固定端</p><p>​    路由器的主要功能: 进行跨网段进行数据传输,路由选择最佳路径</p><p>​    EX:</p><p>​            如果你需要将多台电脑连接到一根网线,用交换机即可</p><p>​            如果你只有一个外网ip, 但是你有好多台电脑需要上网, 用路由器</p><h6 id="2-TCP协议编码流程"><a href="#2-TCP协议编码流程" class="headerlink" title="2.TCP协议编码流程"></a>2.TCP协议编码流程</h6><p>​    服务器端:                                客户端</p><p>实例化对象                            实例化对象</p><p>绑定ip地址和端口号            </p><p>监听</p><p>接收客户端的连接                连接服务器</p><p>收发                                        收发</p><p>关闭                                        关闭</p><pre><code># 服务端import socketimport timesk = socket.socket()sk.bind((&#39;127.0.0.1&#39;, 65534))sk.listen()conn, addr = sk.accept()while 1:    mag_r = conn.recv(1024).decode(&#39;utf-8&#39;)    print(mag_r)    mag_s = input(&#39;&gt;&gt;&gt;&#39;)    conn.send(mag_s.encode(&#39;utf-8&#39;))sk.close()conn.close()# 客户端import socketimport timesk = socket.socket()sk.connect((&#39;127.0.0.1&#39;, 65534))while 1:    mag_r = input(&#39;&gt;&gt;&gt;&#39;)    sk.send(mag_r.encode(&#39;utf-8&#39;))    mag_s = sk.recv(1024).decode(&#39;utf-8&#39;)    print(mag_s)sk.close()</code></pre><h6 id="3-回环地址-127-0-0-1-每个计算机都有的这么一个本机地址-只能被本机识别-不会被其他机器识别"><a href="#3-回环地址-127-0-0-1-每个计算机都有的这么一个本机地址-只能被本机识别-不会被其他机器识别" class="headerlink" title="3.回环地址: 127.0.0.1 每个计算机都有的这么一个本机地址,只能被本机识别,不会被其他机器识别"></a>3.回环地址: 127.0.0.1 每个计算机都有的这么一个本机地址,只能被本机识别,不会被其他机器识别</h6><h6 id="4-tcp三次握手-一定是client先发起请求"><a href="#4-tcp三次握手-一定是client先发起请求" class="headerlink" title="4.tcp三次握手:     一定是client先发起请求"></a>4.tcp三次握手:     一定是client先发起请求</h6><p>​    a. 客户端发起请求连接服务器</p><p>​    b.服务器返回 : 接收到请求, 并要求连接客户端</p><p>​    c.客户端回复: 可以连接</p><h6 id="5-四次挥手-谁先发起断开连接的请求都可以"><a href="#5-四次挥手-谁先发起断开连接的请求都可以" class="headerlink" title="5.四次挥手: 谁先发起断开连接的请求都可以"></a>5.四次挥手: 谁先发起断开连接的请求都可以</h6><p>​    a. 客户端发起断开连接的请求</p><p>​        意思是: 我想和你断开连接,我没有数据要继续发送,但是如果你有数据需要发送,我可以继续接收</p><p>​    b.服务器回复 : 我接收到你的请求了</p><p>​    c.服务器发送 : 我已经准备好断开连接了</p><p>​    d.客户端回复: 收到你的信息, 断开连接</p><h5 id="6-UDP协议"><a href="#6-UDP协议" class="headerlink" title="6.UDP协议"></a>6.UDP协议</h5><p>​    type = SOCK_DGRAM</p><p>​    UDP协议的通信的优势:</p><p>​        允许一个服务器同时和多个客户端通信,    TCP不行</p><pre><code># UDP 服务端import socketsk = socket.socket(type=socket.SOCK_DGRAM)sk.bind((&#39;127.0.0.1&#39;, 8880))  # 绑定ip地址和端口dic = &#123;&#39;alex&#39;: &#39;\033[34m&#39;, &#39;wusir&#39;: &#39;\033[37m&#39;&#125;  # 配颜色while 1:    conn, addr = sk.recvfrom(1024)  # 接收客户端的信息和地址    mag_r = conn.decode(&#39;utf-8&#39;)    name = mag_r.split(&#39;:&#39;)[0].strip()      color = dic.get(name, &#39;&#39;)    print(&#39;%s %s \033[0m&#39; % (color, mag_r))    # print(conn.decode(&#39;utf-8&#39;), addr)    mag_s = input(&#39;&gt;&gt;&gt;&#39;)    sk.sendto(mag_s.encode(&#39;utf-8&#39;), addr)    # if conn == &#39;88&#39;:    #     breaksk.close()</code></pre><p>​                                            </p><pre><code># 客户端# UDPimport socketsk = socket.socket(type=socket.SOCK_DGRAM)  # 指定UDP协议name = input(&#39;请输入您的名字: &#39;)while 1:    mag_s = input(&#39;&gt;&gt;&gt;&#39;)    info = name + &#39; : &#39; + mag_s    sk.sendto(info.encode(&#39;utf-8&#39;), (&#39;127.0.0.1&#39;, 8880))    conn, addr = sk.recvfrom(1024)    print(conn.decode(&#39;utf-8&#39;), addr)sk.close()</code></pre><h5 id="7-pycharm输出带颜色"><a href="#7-pycharm输出带颜色" class="headerlink" title="7.pycharm输出带颜色"></a>7.pycharm输出带颜色</h5><p>​    \033[ 字体颜色: 背景颜色 m  数据  \033[0m</p><h5 id="8-自定义编码和解码类继承socket"><a href="#8-自定义编码和解码类继承socket" class="headerlink" title="8.自定义编码和解码类继承socket"></a>8.自定义编码和解码类继承socket</h5><pre><code>import socket# 自定义编码解码类继承socket文件中的socket类class My_socket(socket.socket):  # 继承自 socket文件中的socket类,此时socket就是父类    def __init__(self, encoding=&#39;utf-8&#39;):        self.encoding = encoding        super(My_socket, self).__init__(type=socket.SOCK_DGRAM)  # 执行父类socket中的__init__方法    def my_sendto(self, mag, addr):        return self.sendto(mag.encode(self.encoding), addr)  # 调用父类中的init方法    def my_recvfrom(self, num):        mag_s, addr = self.recvfrom(num)  # 调用父类中recvfrom方法        return mag_s.decode(self.encoding), addr</code></pre><pre><code>from My_UDP import My_socket# server端sk = My_socket()sk.bind((&#39;127.0.0.1&#39;, 8850))conn, addr = sk.my_recvfrom(1024)print(conn, addr)sk.close()</code></pre><pre><code>from My_UDP import My_socket# client端sk = My_socket()mag_s = input(&#39;&gt;&gt;&gt;&#39;)sk.my_sendto(mag_s, (&#39;127.0.0.1&#39;, 8850))sk.close()</code></pre><h3 id="三-执行命令"><a href="#三-执行命令" class="headerlink" title="三.执行命令"></a>三.执行命令</h3><p>1.在py代码中如何去调用操作系统的命令</p><pre><code># 服务器端import socketimport subprocesssk = socket.socket()sk.bind((&#39;127.0.0.1&#39;, 8080))sk.listen()conn, addr = sk.accept()while 1:    mag_r = conn.recv(1024).decode(&#39;utf-8&#39;)    r = subprocess.Popen(mag_r, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    stdout = r.stdout.read()    stderr = r.stderr.read()    if stderr:        conn.send(stderr)    else:        conn.send(stdout)conn.close()sk.close()</code></pre><pre><code># 客户端# 客户端发送要执行的命令# 服务器执行, 执行完将结果返回给客户端# 客户端拿到结果呈现到用户眼前import socketsk = socket.socket()sk.connect((&#39;127.0.0.1&#39;, 8080))while 1:    cmd = input(&#39;请输入一个命令&gt;&gt;&gt;&#39;)    sk.send(cmd.encode(&#39;utf-8&#39;))    result = sk.recv(2048).decode(&#39;gbk&#39;)    print(result)sk.close()</code></pre><p>2.新模块; subprocess</p><pre><code>r = subprocess.Popen(mag_r, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)stdout = r.stdout.read()stderr = r.stderr.read()# mag_r    : 代表系统命令# shell=True    代表这条命令是系统命令,告诉操作系统,将mag_r当做系统命令去执行# stdout    是执行完系统命令之后,用于保存正确结果的一个管道# stderr    实执行完系统命令之后,用于保存错误结果的一个管道print(r.stdout.read().decode(&#39;gbk&#39;))print(r.stderr.read().decode(&#39;gbk&#39;)) # 操作系统默认编码是gbk</code></pre><h3 id="四-粘包问题"><a href="#四-粘包问题" class="headerlink" title="四.粘包问题"></a>四.粘包问题</h3><h6 id="1-只有tcp协议才会有粘包-udp不会发生"><a href="#1-只有tcp协议才会有粘包-udp不会发生" class="headerlink" title="1.只有tcp协议才会有粘包,udp不会发生"></a>1.只有tcp协议才会有粘包,udp不会发生</h6><p>EX:    发送端发送数据,  接收端不知道应该去如何去接收, 造成的一种数据混乱的现象</p><h6 id="2-在tcp协议中有两个机制"><a href="#2-在tcp协议中有两个机制" class="headerlink" title="2.在tcp协议中有两个机制"></a>2.在tcp协议中有两个机制</h6><p>​    1.合包机制(nagle算法) 将多次连续发送且间隔较小的数据, 进行打包成一块数据发送过去</p><p>​    2.拆包机制,在发送端,因为受到网卡的MTU限制, 会将大的超过MTU限制的数据, 拆分成多个小的数据,进行传输, 当传输到目标主机的操作系统层时, 会重新将多个小的数据合并成原本的数据</p><h6 id="3-MTU-数据链路层"><a href="#3-MTU-数据链路层" class="headerlink" title="3.MTU(数据链路层)"></a>3.MTU(数据链路层)</h6><p>​    MTU是Maximum Transmission Unit 的缩写. 意思是网络上传送的最大数据包, MTU的单位是字节, 大部分网络设备的MTU都是1500, 如果本机的MTU比网关的MTU大, 大的数据包就会被拆开来发送,这样会产生很多数据包碎片，增加丢包率，降低网络速度</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python模块</title>
      <link href="/2020/11/11/python%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/11/11/python%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="一-模块初识"><a href="#一-模块初识" class="headerlink" title="一.模块初识"></a>一.模块初识</h3><ul><li>模块的分类<ul><li>内置模块<ul><li>安装python解释器的时候跟着装上的那些方法</li></ul></li><li>第三方模块<ul><li>没在安装怕python解释器的时候安装的那些功能</li></ul></li><li>自定义功能<ul><li>自己写的功能是一个通用的功能，可以当作是一个模块</li></ul></li></ul></li><li>模块的定义<ul><li>有的功能开发者自己无法完成，这样的话需要借助已经实现的函数/类来完成这些功能</li><li>自己实现不了的功能由别人代替了<ul><li>比如：和操作系统打交道</li><li>和时间</li><li>随机数</li><li>压缩一个文件</li><li>和网络通信</li></ul></li><li>别人写好的一组功能–&gt; 文件夹/py文件/c语言编译好的一些编译文件</li></ul></li><li>模块的好处<ul><li>分类  管理方法</li><li>节省内存</li><li>提供更多的功能</li></ul></li><li>为什么要有模块?<ul><li>分类, 管理方法</li><li>节省内存</li><li>提供更多的功能</li></ul></li></ul><ul><li>模块的创建和导入</li></ul><pre><code># 自定义模块,模块的创建# py文件名--&gt;my_moduleprint(&#39;这是我的模块&#39;)name = &#39;alex&#39;def login():    print(&#39;这是一个登录函数&#39;)# 模块的导入import my_module  # 要导入一个py文件的名字,但是不加.py后缀名                    # 模块的名字必须要满足变量的命名规范                    # 一般情况下,模块都是小写字母开头的名字# import这个模块相当于执行了这个模块所在的py文件# 模块不会被多次导入# 模块的使用my_module.login()print(my_module.name)  # 直接调用导入进来模块的方法以及属性等等# 模块的重命名import my_module as m  # 语法  import 模块名 as 新名字m.login()print(m.name)# 导入多个模块import osimport my_module# PEP8规范# 所有的模块导入都应该尽量放在这个文件的开头# 模块的导入也是有顺序的    # 先导入内置模块    # 再导入第三方模块    # 最后导入自定义模块</code></pre><ul><li>from_import<ul><li>from import的时候执行了什么??<ul><li>想当于执行了整个py文件</li></ul></li><li>导入了什么,就能是有什么, 不导入的变量, 不能使用</li><li>不导入并不意味着不存, 而是没有建立文件到模块中其他名字的引用</li><li>当模块中的方法或者变量  和 文件重名时, 那么这个名字只代表最后一次对他赋值的那个</li><li>在本文件中对全局变量的修改是完全不影响模块中的变量引用的</li></ul></li><li>模块的重命名</li></ul><pre><code>from module1 import login as l1</code></pre><ul><li>导入多个重命名</li></ul><pre><code>from module1 import login as l1, name as l2</code></pre><ul><li>from 模块 import *</li></ul><pre><code>__all__ = [&#39;age&#39;]  #可以控制*导入的东西,这里只表示导入agename = &#39;alex&#39;age = 19def login():    print(&#39;in my login&#39;)def asd():    print(&#39;in my asd&#39;)if __name__ == &#39;__main__&#39;:  # 所有测试语句方法在里面,在导入模块之后,执行脚本的时候就不会自动执行    login()    asd()from module1 import *  # *表示导入模块中所有的变量和方法print(age)# print(name)# asd()# login()</code></pre><ul><li><p>pyc编译文件</p><ol><li>python的执行  —&gt;  解释-编译</li><li>当一个文件作为一个脚本被导入的时候</li><li>就会在这个文件所在的目录的_ _ pycache _ _下生成一个编译好的文件</li><li>为了之后导入这个文件的时候直接读这个编译好的pyc文件</li><li>可以节省一些导入的时间</li></ol></li><li><p>运行一个py 文件的两中方式</p><ol><li>以模块的形式运行</li></ol></li></ul><pre><code>import my_moduleif __name__ == &#39;__main__&#39;:    my_module.login()</code></pre><ol start="2"><li><p>直接pycharm运行  cmd运行</p><pre><code>          1. 就是以脚本的方式运行                   2. 那么需要在本文件中直接打印的代码上加上                            3. if _ _ name _ _ = [&#39;_ _ main _ _&#39;]                                     4. 在编写py文件的时候                                       1. 所有不在函数和类中封装的内容都应该写在                                                   2. if _ _ name _ _ = [&#39;_ _ main _ _&#39;] : 下面</code></pre><pre><code>import sysimport module1print(sys.modules)  # 结果是: 存储了所有导入的文件的名字和这个文件的内存地址&#123;sys : 文件的内存地址,&#39;__main__&#39; : 当前执行文件所在的地址&#125;# 再次使用反射反射自己模块中的内容的时候import sysprint(getattr(sys.modules[__name__], &#39;name&#39;))</code></pre></li></ol><p>​                </p><ul><li><p>模块搜索路径</p><ol><li>模块没导入之前是在硬盘上的</li><li>模块的搜索路径全部存储在sys.path列表中</li><li>导入模块的顺序,是从前到后找到一个符合条件的模块就立即停止不再向后寻找</li><li>如果要导入的模块和当前执行文件是同级目录<ol><li>直接导入即可</li></ol></li><li>如果要导入的模块和当前执行的文件不是同级<ol><li>需要吧导入的模块的绝对路径添加到sys.path 列表中</li></ol></li></ol></li><li><p>重新加载模块</p><ul><li>在import之后  再修改这个被导入的模块, 程序是感知不到的</li><li>reload这种方法可以强制程序再重新导入这个模块一次(非常不推荐使用)</li></ul></li></ul><pre><code>import module1import timeimport importlibmodule1.login()time.sleep(20)importlib.reload(module1)  # 表示重新加载module1.login()</code></pre><ul><li>模块的循环使用<ol><li>在模块的导入中, 不要产生循环引用问题</li><li>如果发生循环导入了, 就会发现明明写在这个模块中的方法, 显示找不到</li></ol></li></ul><h3 id="二-包"><a href="#二-包" class="headerlink" title="二.包"></a>二.包</h3><ul><li>导入包相当于执行了这个包下面的 _ _ init _ _ 方法</li><li>可以设 _ _ init _ _方法来完成一些模块的导入</li><li>如果直接导入一个包, 那么相当于执行了这个包中的_ _ init _ _文件,并不会帮你把这个包下面的其他包以及py文件自动的导入到内存</li></ul><pre><code># import bbb.api.policy# bbb.api.policy.get()import bbb.api.policy as a1a1.get()</code></pre><ol><li><p>绝对导入和相对导入</p><pre><code>在glance/api/version.py#绝对导入from glance.cmd import managemanage.main()#相对导入from ..cmd import managemanage.main()</code></pre></li></ol><h3 id="三-正则表达式"><a href="#三-正则表达式" class="headerlink" title="三.正则表达式"></a>三.正则表达式</h3><ul><li><p>定义: 就是一种匹配字符串的规则</p></li><li><p>应用: 登录注册的表单验证,爬虫,自动化开发, 日志分析</p></li><li><p>正则表达式是一种独特的语法,和python没有关系</p></li><li><p>帮助学习工具 <a href="http://tool.chinaz.com/regex/">http://tool.chinaz.com/regex/</a></p></li></ul><ol><li>字符组 []<ol><li>在一个字符的位置上能出现的内容</li><li>[1abc]   是一个范围</li><li>[0-9] [A-Z] [a-z]  表示匹配三个字符</li><li>[abc0-9]  表示匹配一个字符</li><li>[0-9a-zA-Z]  表示匹配一个字符</li><li>[^]  非字符组</li></ol></li><li>元字符<ol><li>\d == [0-9] 也表示匹配一个字符, 匹配的是一个数字</li><li>\w == [0-9a-zA-Z] 也表示匹配一个数字字母下划线</li><li>\s == [\n \t]  包括回车 空格 和 制表符tab \n匹配回车  \t 匹配制表符</li><li>\D 匹配非数字</li><li>\W 匹配非数字字母下划线</li><li>\S 匹配非空白</li><li>\b 匹配单词的开始或结束</li><li>| 或者的意思</li><li>() 分组的意思</li><li>^  匹配字符串的开始</li><li>&amp; 匹配字符串的结束</li><li>.  除了换行符的所有</li><li>[\d\D] [\w\W] [\s\S]  匹配所有</li></ol></li><li>量词<ol><li>?  重复0次或者一次(也就是可有可无)</li><li>+重复1次或者更多次(1~多次)</li><li>*重复0次或者更多次(0~多次)</li><li>{n} 重复n次</li><li>{n,} 重复至少n次</li><li>{n,m} 重复n到m次</li></ol></li><li>其他<ol><li>贪婪匹配(回溯算法) 尽可能的匹配多的</li><li>量词?  表示惰性匹配也就是取消贪婪匹配<ol><li>?? *? +? {n}?</li><li>最常用 .*?x   表示任意字符找到一个x</li></ol></li></ol></li><li>正则表达式的例子</li></ol><pre><code>1.匹配任意长度的正整数    [1-9]\d*2.匹配小数    -?\d+\.\d+3.匹配整数或者小数    -?\d+\.?\d*  有缺陷 1. 2. 这样的内容也会匹配上    -?\d+\.?\d+  有缺陷 1 2 这样的一位数就匹配不上了    -?\d+(\.\d+)? 准确的4.匹配负数    -0\.\d+|-[1-9]\d*(\.\d+)?5.匹配qq号    [1-9]\d&#123;5,11&#125;6.匹配长度为11位的电话号码    1[3-9]\d&#123;9&#125;7.匹配长度为8-10位的用户密码 包含数字字母下划线和?@    [\w?@]&#123;8,10&#125;8.匹配验证码,4位数字字母组成的    [\da-zA-Z]&#123;4&#125;9.1-2*((60-30+(-40/5)*(9-2*5/3+7/3*99/4*2998+10*568/14))-(-4*3)/(16-3*2))匹配出最内层的小括号    \([\d\.+\-*/]+\)    \([^()]+\)</code></pre><p> 6.转义符</p><p>​    1.正则表达式中的转义</p><p>​        ‘\ (‘ 表示转义小括号</p><pre><code>     # [()+*?/$.]   在字符组中一些特殊的字符会现出原形# 所有的 \w \d \s(\n,\t, )  \W \D \S都表示它原本的意义# [-]只有写在字符组的首位的时候表示普通的减号#    写在其他位置的时候表示范围[1-9]#    如果就是想匹配减号 [1\-9]</code></pre><p>​    2.python中的转义</p><pre><code># 分析过程&#39;\n&#39;  # \转义符 赋予这个n一个特殊的意义 表示一个换行符# print(&#39;\\n&#39;)# print\\n(&#39;C:\\next&#39;)# print(r&#39;C:\next&#39;)# &#39;\\\\n&#39; &#39;\\n&#39;# 结论# r&#39;\\n&#39; r&#39;\n&#39;  在python中</code></pre><h3 id="四-re模块"><a href="#四-re模块" class="headerlink" title="四.re模块"></a>四.re模块</h3><p>​    1.匹配</p><p>​    findall 和 search match</p><pre><code>import re# findall# print(re.findall(&#39;\d&#39;, &#39;asdf23&#39;))# 参数 返回值类型(列表),返回值个数(1) 返回值内容:所有匹配上的内容# searchret = re.search(&#39;\d+&#39;, &quot;afasdf1231adf212&quot;)  # 返回值类型: 正则匹配结果的对象  返回值个数:1 如果匹配上了就返回对象print(ret.group())  # 返回的对象是通过group 来获取匹配到的第一个结果如果没有匹配上,结果就是None# matchret1 = re.match(&#39;\d+&#39;, &#39;*&amp;1231afasdf1231adf212&#39;)  # 只匹配前面出现的,不然会报错print(ret1.group())</code></pre><p>​    2.替换</p><p>​    sub 和 subn</p><pre><code># sub 和 replace是一样的print(re.sub(&#39;\d+&#39;, &#39;H&#39;, &#39;123FSDF52FSF1&#39;))# subn  会打印你替换了的次数print(re.subn(&#39;\d+&#39;, &#39;H&#39;, &#39;123FSDF52FSF1&#39;))结果:(&#39;HFSDFHFSFH&#39;, 3)</code></pre><pre><code> 3.切割</code></pre><p>​    split</p><pre><code>print(re.split(&#39;\d+&#39;, &#39;123faaf23&#39;))# 会把数字不打印# 结果是个列表 [&#39;&#39;, &#39;faaf&#39;, &#39;&#39;]</code></pre><p>​    4.进阶方法</p><p>​    compile(时间效率) 和 finditer(空间效率)</p><pre><code># compile 起到一个预编译的作用,只有多次使用某一个相同的正则表达式的时候,compile才会提高我们程序的效率ret = re.compile(&#39;-0\.\d+|-[1-9]+(\.\d+)?&#39;)res = ret.search(&#39;asdf-0.01-99&#39;)print(res.group())# finditerret = re.finditer(&#39;\d&#39;, &#39;adfad12fasdf123&#39;)  # 返回的是一个迭代器print(ret)for i in ret:    print(i.group())</code></pre><p>​    5.python中的正则表达式</p><p>​        1.findall 会优先显示分组中的内容,要想取消分组优先,(?:正则表达式)</p><p>​        2.split 遇到分组 会保留分组内被切掉的内容</p><p>​        3.search 如果search中有分组的话,通过group(n)就能够拿到group中的匹配的内容</p><pre><code>ret = re.findall(&#39;-0\.\d+|-[1-9]\d*(?:\.\d+)?&#39;, &#39;-1asdada-200&#39;)print(ret)ret = re.split(&#39;(\d+)&#39;,&#39;alex83egon20taibai40&#39;)print(ret)# 分组遇见searchret = re.search(&#39;\d+(.\d+)(.\d+)(.\d+)?&#39;,&#39;1.2.3.4-2*(60+(-40.35/5)-(-4*3))&#39;)print(ret.group())print(ret.group(1))print(ret.group(2))print(ret.group(3))</code></pre><pre><code> 6. 分组命名      1. (?P&lt; name &gt; 正则表达式)  表示给分组起名字      2. (?P=name) 表示使用这个分组,这里匹配到的内容应该和分组中的内容完全相同7. 通过索引使用分组        1. \1 表示使用第一组, 匹配到的内容和分组中的内容完全相同</code></pre><pre><code>import re# ret=re.findall(r&quot;\d+(?:\.\d+)?&quot;,&quot;1-2*(60+(-40.35/5)-(-4*3))&quot;)# print(ret)# ret=re.findall(r&quot;\d+(?:\.\d+)|(\d+)&quot;,&quot;1-2*(60+(-40.35/5)-(-4*3))&quot;)# print(ret)# ret.remove(&#39;&#39;)# print(ret)import re# ret = re.findall(&#39;&gt;(\w+)&lt;&#39;,r&#39;&lt;a&gt;wahaha&lt;\a&gt;&#39;)# print(ret)# ret = re.search(r&#39;&lt;(\w+)&gt;(\w+)&lt;/(\w+)&gt;&#39;,r&#39;&lt;a&gt;wahaha&lt;/b&gt;&#39;)# print(ret.group())# print(ret.group(1))# print(ret.group(2))分组命名ret = re.search(&quot;&lt;(?P&lt;name&gt;\w+)&gt;\w+&lt;/(?P=name)&gt;&quot;,&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)print(ret.group(&#39;name&#39;))  #结果 ：h1# print(ret.group())  #结果 ：&lt;h1&gt;hello&lt;/h1&gt;ret = re.search(r&quot;&lt;(\w+)&gt;\w+&lt;/\1&gt;&quot;,&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)print(ret.group(1))# print(ret.group())  #结果 ：&lt;h1&gt;hello&lt;/h1&gt;ret = re.search(r&#39;&lt;(?P&lt;tag&gt;\w+)&gt;(?P&lt;c&gt;\w+)&lt;/(\w+)&gt;&#39;,r&#39;&lt;a&gt;wahaha&lt;/b&gt;&#39;)print(ret.group())print(ret.group(&#39;tag&#39;))print(ret.group(&#39;c&#39;))</code></pre><h4 id="五-爬虫练习"><a href="#五-爬虫练习" class="headerlink" title="五.爬虫练习"></a>五.爬虫练习</h4><pre><code>import refrom urllib.request import urlopen# 内置的包,来获取网页的源代码 字符串def getPage(url):    reponse = urlopen(url)    return reponse.read().decode(&#39;utf-8&#39;)def parsePage(s):    ret = com.finditer(s)    for i in ret:        ret = &#123;            &quot;id&quot;: i.group(&quot;id&quot;),            &quot;title&quot;: i.group(&quot;title&quot;),            &quot;rating_num&quot;: i.group(&quot;rating_num&quot;),            &quot;comment_num&quot;: i.group(&quot;comment_num&quot;)        &#125;        yield retdef main(num):    url = &#39;https://movie.douban.com/top250?start=%s&amp;filter=&#39; % num    reponse_html = getPage(url)    ret = parsePage(reponse_html)    print(ret)    f = open(&#39;info1&#39;,encoding=&#39;utf-8&#39;)    for obj in ret:        print(obj)        data = str(obj)        f.write(data, &#39;\n&#39;)    f.close()com = re.compile(    &#39;&lt;div class=&quot;item&quot;&gt;.*?&lt;div class=&quot;pic&quot;&gt;.*?&lt;em .*?&gt;(?P&lt;id&gt;\d+).*?&lt;span class=&quot;title&quot;&gt;(?P&lt;title&gt;.*?)&lt;/span&gt;&#39;    &#39;.*?&lt;span class=&quot;rating_num&quot; .*?&gt;(?P&lt;rating_num&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;comment_num&gt;.*?)评价&lt;/span&gt;&#39;, re.S)count = 0for i in range(10):    main(count)    count += 25</code></pre><h3 id="六-验证码代码"><a href="#六-验证码代码" class="headerlink" title="六.验证码代码"></a>六.验证码代码</h3><pre><code># 验证码import randomdef rand_code(n=6, flag=True):    code = &#39;&#39;    for i in range(n):        rand_num = str(random.randint(0, 9))        if flag == True:            rand_alph = chr(random.randint(97, 122))  # 是根据ASCLL 表 获取小写字母,97-127(a-z)            rand_alph_upper = chr(random.randint(65, 90))  # 是根据ASCLL表 获取大写字母 65-90(A-Z)            rand_num = random.choice([rand_num, rand_alph, rand_alph_upper])        code += rand_num    return coderet = rand_code(flag=False)print(ret)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/11/07/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B4%E7%90%86/"/>
      <url>/2020/11/07/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一-面向对象"><a href="#一-面向对象" class="headerlink" title="一.面向对象"></a>一.面向对象</h3><h6 id="1-写代码的时候-什么时候用面向对象"><a href="#1-写代码的时候-什么时候用面向对象" class="headerlink" title="1.写代码的时候,什么时候用面向对象"></a>1.写代码的时候,什么时候用面向对象</h6><ul><li>代码量大,功能多的时候</li><li>处理比较复杂的角色之间的关系(面试可以这么说)<ul><li>qq 好友 陌生人 群 组</li><li>复杂的电商程序</li><li>公司/学校的人事管理/功能的系统</li></ul></li><li>面向对象的好处<ul><li>代码的清晰度更高了</li><li>可读性,无论是开发者,还是调用者,都能明确的分辨出每个角色拥有的方法和属性</li><li>增强了代码的可扩展性</li><li>增加复用性</li><li>更加规范</li></ul></li></ul><h6 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h6><ul><li>Python当中一切皆对象, 基础数据类型 都是对象</li><li>类型和自定义类的关系–&gt;类型和类是一个东西<ul><li>type(obj) obj 是一个对象,那么它的type就是它的类型</li></ul></li><li>创建一个对象<ul><li>类名() 实例化一个对象</li><li><strong>new</strong>() 创造了一个对象的空间,一些简单的初始化</li></ul></li><li>创建一个类<ul><li>class 类名  —&gt;语法级别的 Python解释器读到这句话的时候,就会创建类</li><li>type是所有类的元类, object是所有类的父类</li><li>类也是被创建出来的,type创建类, type(cls)  = type<ul><li>class A(metaclass = ABCMeta) ABCMeta创建了这个A类,那么ABCMeta就是A的元类</li><li>那么 type 就是这个类的 元类</li></ul></li></ul></li><li>type(obj) 的结果就是这个对象所属的类</li><li>type(类) 的结果及时创建这个类的元类, 大多数情况下就是type,除非你指定metaclass</li></ul><pre><code>class Saler:    def __init__(self, name, sex, ident):        self.name = name        self.sex = sex        self.ident = ident    def sale(self):        print(&#39;%s卖东西&#39; % self.name)    def add_goods(self):        passalex = Saler(&#39;alex&#39;, None, &#39;looser&#39;)print(type(alex))print(type(Saler))  # Saler类 --&gt; Saler类型 类型的类型 = 类型</code></pre><h6 id="3-类-class-类名"><a href="#3-类-class-类名" class="headerlink" title="3. 类 class 类名"></a>3. 类 class 类名</h6><ul><li><p>类是什么时候被加载的, 以及类名是什么时候生效的</p></li><li><p>类</p><ul><li>静态属性/静态字段/静态变量</li><li>动态属性/方法</li></ul><pre><code>class Person:    role = &#39;china&#39;    print(role)    def func(self):        passa = Person()print(Person.func)  # &lt;function Person.func at 0x000001999CEBF1F8&gt;print(a.func)  # &lt;bound method Person.func of &lt;__main__.Person object at 0x000001999CEE1C48&gt;&gt;内存地址是不一样的,如下</code></pre></li></ul><p><img src="C:\Users\付举鹏\AppData\Roaming\Typora\typora-user-images\1604742664127.png" alt="1604742664127"></p><h6 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h6><ul><li>类创造对象的过程就是实例化的过程 :  构造new, 初始化 init</li><li>可以通过指针找到类的空间中的内容</li><li>对象本身内部存储了一些只属于对象的属性</li></ul><h6 id="5-组合"><a href="#5-组合" class="headerlink" title="5.组合"></a>5.组合</h6><ul><li>什么有什么的关系 (比如: 学生和课程的关系)</li><li>一个类的对象作为一个类的属性(组合的定义)</li></ul><h6 id="6-继承"><a href="#6-继承" class="headerlink" title="6.继承"></a>6.继承</h6><pre><code>class Foo:    def __init__(self):        self.func()    def func(self): print(&#39;Foo.func&#39;)class Son(Foo):    def func(self): print(&#39;Son.func&#39;)s = Son()结果是 : Son.func</code></pre><ul><li><p>什么是什么的关系 (dog 和 Animal 的关系) 节省代码</p></li><li><p>子类 和 父类</p></li><li><p>单继承  和  多继承</p><ul><li><p>单继承</p><ul><li>如果子类的对象调用某个方法<ul><li>子类有: 调用子类的<ul><li>子类有单想调用父类的:<ul><li>super : 不用自己传self super(子类,self).方法名(除了self之外的参数)</li><li>父类名:  父类名.方法名(self,…)</li></ul></li></ul></li><li>子类没有,找父类</li></ul></li><li>注意 在任意类中调用的方法,都要仔细分辨以下这个self到底是谁的对象</li></ul></li><li><p>多继承</p></li><li><p>新式类: 广度优先 - c3算法</p><ul><li>mro方法查看继承顺序</li><li>py3 中默认继承object, 所以py3 中都是新式类<ul><li>super().func() 遵循mro算法, 在类的内部不用传子类名和self</li></ul></li><li>py2 中需要主动继承object<ul><li>super(子类名,self).func() 必须传子类名和self</li><li>经典类: 深度优先</li></ul></li><li>py2 不继承object, 默认都是经典类</li><li>没有mro算法</li></ul></li></ul></li></ul><pre><code>class A:    def func(self):        print(&#39;A&#39;)class B(A):    def func(self):        super(B, self).func()        print(&#39;B&#39;)class C(A):    def func(self):        super(C, self).func()  # 这里super(C, self) 是默认的,可以不传,在python3中        print(&#39;C&#39;)class D(B, C):    def func(self):        super().func()        print(&#39;D&#39;)d = D()d.func()结果是A C B D 执行顺序遵循mro算法 mro执行顺序: dbcab = B()b.func()</code></pre><p><img src="C:\Users\付举鹏\AppData\Roaming\Typora\typora-user-images\1604742755894.png" alt="1604742755894"></p><h6 id="7-抽象类和接口"><a href="#7-抽象类和接口" class="headerlink" title="7.抽象类和接口"></a>7.抽象类和接口</h6><ul><li>不能被实例化</li><li>规范子类当中必须实现某个方法</li><li>有原生的实现抽象类的方法,但是没有原生实现接口类的方法</li><li>抽象类: 抽象类中的方法是可以实现的  只能单继承</li><li>接口类: 可以多继承 但是这个类中的所有方法都不应该被实现<ul><li>java中<ul><li>java 只支持类的单继承  抽象类 父类的方法可以实现</li><li>接口 interface 支持多继承的规范 . 接口中的所有方法 只能写pass</li></ul></li></ul></li></ul><h6 id="8-多态"><a href="#8-多态" class="headerlink" title="8.多态"></a>8.多态</h6><ul><li>在python中处处存在</li><li>定义:  一种类型的多种形态, 多个子类去继承父类, 那么每一个子类都是这个父类的一种形态</li></ul><pre><code>class Animal:passclass Tiger(Animal):passclass Frog(Animal):pass</code></pre><ul><li>鸭子类型:  规范全凭自觉</li></ul><h6 id="9-封装"><a href="#9-封装" class="headerlink" title="9.封装"></a>9.封装</h6><ul><li>私有的<ul><li>广义的封装: 把方法和属性都封装在一个类里,定义一个规范来描述一类事物</li><li>狭义的封装: 私有化 只能在类的内部访问</li><li>__静态变量, 私有方法  , 私有的对象属性, 私有的类方法 , 私有的静态方法</li><li>在内存中的存储形式:  _类名__名字</li><li>为什么在类的内部可以使用双下划线访问 : 在类的内部使用, 你就知道在哪个类中</li><li>在子类中可以访问父类私有变量吗? 不行</li><li>私有 :  不能在类的外部使用也不能被继承</li></ul></li></ul><h6 id="10-property"><a href="#10-property" class="headerlink" title="10.property"></a>10.property</h6><ul><li>是装饰器函数, 内置函数, 帮助你将类中的方法伪装成属性 , 也叫特性</li><li>调用方法的时候不需要主动加括号</li><li>让程序的逻辑性更合理</li><li>@方法名.setter  装饰器, 修改被property装饰的属性的时候会调用被这个装饰器装饰的方法,除了self之外还有一个参数, 被修改的值</li><li>@ 方法名.deleter 装饰器,当要删除被property装饰的属性的时候会调用被这个装饰器装饰的方法</li><li>只用property</li></ul><pre><code>class Circle:    def __init__(self, r):        self.r = r    @property    def area(self):        return 3.14*self.r**2  # 这个方法计算结果本身就是一个属性,但是这个属性会随着这个类/对象的一个基础变量的变化而变化c = Circle(5)print(c.area)c = Circle(1)print(c.area)</code></pre><ul><li>其他语言 property+私有的 合用 , 这时候更多的也会用到setter 和 deleter</li></ul><pre><code>class A:    def __init__(self, name):        self.__name = name    @property    def name(self):        return self.__name    @name.setter    def name(self, new_name):        if type(new_name) is str:            self.__name = new_name    @name.deleter    def name(self):        del self.__namea = A(123)print(a.name)</code></pre><p><img src="C:\Users\付举鹏\AppData\Roaming\Typora\typora-user-images\1604742788101.png" alt="1604742788101"></p><h6 id="11-classmethod"><a href="#11-classmethod" class="headerlink" title="11.classmethod"></a>11.classmethod</h6><ul><li>类方法的装饰器  内置函数</li><li>使用类名调用, 默认传类名作为第一个参数</li><li>不用对象命名空间中的内容, 而用到了类命名空间中的变量(静态属性) 或者类方法或静态方法</li></ul><pre><code>class Goods:    __discount = 0.8    def __init__(self, price):        self.__price = price    @property    def price(self):        return self.__price * Goods.__discount    @classmethod    def change_discout(cls, num):        cls.__discount = num## 商场的程序apple = Goods(5)banana = Goods(10)print(apple.price, banana.price)Goods.change_discout(1)  # 类名调用类方法 这里是改变__discount的值print(apple.price, banana.price)</code></pre><h6 id="12-staticmethod"><a href="#12-staticmethod" class="headerlink" title="12.staticmethod"></a>12.staticmethod</h6><ul><li>静态方法的装饰器  内置函数</li><li>如果一个类里面的方法, 既不需要用到self中的资源, 也不用cls 中的资源</li><li>相当于一个普通函数</li><li>但是你由于某种原因, 还是要把这个方法放在类中,这是时候,就将这个方法变成一个静态方法</li><li>某种原因<ul><li>你完全想用面向对象编程, 所有的函数都必须写在类中</li><li>某个功能确确实实是这个类的方法, 但是确确实实没有用到这个类有关系的资源</li></ul></li><li>比如 : 学生 管理员    课程  和  班级</li></ul><pre><code>class Person:    @staticmethod    def login():  # 动词 动作  属于某一个对象 用不到类的资源        passclass Student(Person):passclass Manager(Person):passclass Course:passclass Classes:pass</code></pre><h5 id="13-object-new-重点"><a href="#13-object-new-重点" class="headerlink" title="13.object.new() 重点"></a>13.object.<strong>new</strong>() 重点</h5><h5 id="14-反射-重点"><a href="#14-反射-重点" class="headerlink" title="14.反射(重点)"></a>14.反射(重点)</h5><ul><li>从某个指定的命名空间中, 用字符串数据类型的变量名来获取变量的值</li><li>类名反射  静态属性 类方法 静态方法</li><li>对象反射  对象属性  方法</li><li>模块   模块中的方法</li><li>自己模块中<ul><li>import sys</li><li>mymodule = sys.modules[‘<strong>main</strong>‘]</li><li>getattr(mymodule,’变量名’)</li></ul></li><li>hasattr/getattr/setattr/delattr</li><li>参数<ul><li>(命名空间,’变量名’)</li><li>setattr(命名空间,’变量名’,新的值)</li></ul></li><li>变量名, 你只能拿到一个字符串的版本<ul><li>可以从文件里拿</li><li>交互拿 :  input/ 网络传输(二进制–&gt; bytes类型–&gt;str)</li></ul></li></ul><h5 id="14-进阶"><a href="#14-进阶" class="headerlink" title="14.进阶"></a>14.进阶</h5><ul><li>内置方法/魔术方法/双下方法</li><li>_  _名字__  不是被直接调用的</li><li>间接调用: 内置函数/面向对象中的特殊语法/python提供的语法糖 (语法糖,就是给程序员提供了更实用的编码方式,有利于更好的编码风格,更易读)</li></ul><pre><code>x = 5y = 6print(x.add__(y))print(x + y)  # 语法糖,和上面实现的功能是一样的</code></pre><ul><li><p>_ <em>str__ : str(obj) . 要求必须实现</em> _ _ str__ ,要求这个方法的返回值必须是字符串str类型</p><ul><li>应用场景 :  print %s str </li></ul></li><li><p>_ _call__ :  相当于对象()  用类写装饰器</p></li><li><p>_ <em>len__ :  len(obj) , 要求必须实现了</em> _ len__ ,  要求这个方法的返回值必须是数字int类型</p></li><li><p>_ _new__:   在实例化的过程中, 最先执行的方法,在执行init之前, 用来创造一个对象, 是一个构造方法</p><ul><li>经典的单利类</li></ul></li><li><p>_ _init__ :  在实例化过程中,在new执行之后, 自动触发的一个初始化方法</p></li><li><p>_ _ add__:  加法</p></li></ul><pre><code>class MyType:    def __init__(self, s):        self.s = s    def __add__(self, other):        return self.s.count(&#39;*&#39;) + other.s.count(&#39;*&#39;)obj1 = MyType(&#39;asdf*****&#39;)obj2 = MyType(&#39;xfg****&#39;)print(obj1 + obj2)print(obj1.__add__(obj2))</code></pre><ul><li>_ <em>repr__ :  是</em>  _ <em>str__的备胎, 如果有     _ _str</em> _ 方法,那么 print, %s, str  都先会执行  _ <em>str</em> _ 方法,并且使用_ _str__的返回值<ul><li>如果没有_ _ str __ ,那么print %s str 都会执行repr</li><li>应用场景  repr(obj) %r </li></ul></li><li>在子类中使用_ _ str _ <em>,先找子类的</em> _ _ str _ _. 没有的话向上找,只要父类不是object,就执行父类的 _ _ str _ _方法</li><li>但是如果除了object之外的父类都没有 _ _ str _ _ 方法, 就执行子类的 _ _ repr _ _,如果子类也没有,还要向上找继续找父类中的 _ _ repr __ 方法</li></ul><pre><code>class A:    def __init__(self, name):        self.name = name    def __str__(self):        return &#39;**%s**&#39; % self.name    def __repr__(self):        return self.nameclass B(A):    def __init__(self, name):        self.name = name    def __repr__(self):        return &#39;***&#39;b = B(&#39;alex&#39;)print(b)print(str(b), repr(b))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python面向对象的总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/10/13/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/10/13/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一-面向对象的初始"><a href="#一-面向对象的初始" class="headerlink" title="一.面向对象的初始"></a>一.面向对象的初始</h3><p>​    1.类 : 具有相同属性和技能的一类事物</p><p>​    2.对象 : 具体类的表现, 具体的实实在在的一个实例</p><p>​    </p><pre><code>class Person:    &#39;&#39;&#39; 类体:两部分: 变量部分,方法(函数)部分 &#39;&#39;&#39;    mind = &#39;有思想&#39;  # 变量,一般叫(静态变量,静态字段)    animal = &#39;高级动物&#39;    faith = &#39;有信仰&#39;    def __init__(self):        print(66)    def work(self):  # 方法,函数,动态变量        print(&quot;人类都会工作&quot;)    def shop(self):        print(&quot;人类可以消费....&quot;)        self.hight = 175 # 方法中也可以封装属性# 类名的角度    # 类中的静态变量        # 1. Person.__dict__ 查询类中的所有内容,不能进行增删改查# print(Person.__dict__)# print(Person.__dict__[&#39;faith&#39;]) # 获取类中静态字段具体的值# Person.__dict__[&#39;mind&#39;] = &#39;无脑&#39; # 报错# print(Person.__dict__[&#39;mind&#39;])        # 2. 万能的点 . 对类中的单个的变量进行增删改查# print(Person.mind)  # 查# print(Person.animal) # 查# Person.money = &#39;运用货币&#39; 增# Person.mind = &#39;无脑&#39; # 改# del Person.mind  # 删除# print(Person.__dict__) # 打印类中所有的内容        # 3. 操作类中的方法 (工作中基本不用类名去操作)        # 3. 除了类方法,静态方法,需要类名调用之外,剩下的方法都要对象调用# Person.work(11)# 对象的角度# ret = Person() # 类名 + () 的这个过程: 实例化的过程( 创建一个对象的过程 )    # Person() 实例化对象,实例,对象# print(ret)#  1. 只要类名 + () 产生一个对象,自动执行类中__init__方法.执行步骤# 1. 类名+() 产生一个实例 ( 对象,对象空间 )# 2. 自动执行类中的__init__方法,将对象空间传给__init__的self参数# 3. 给对象封装相应的属性(变量)# print(ret.__dict__) # 查询对象中的所有内容 结果是 字典&#123;&#125;# 执行过程# 1.创建了一个对象空间,实例空间# 2. 自动执行__init__方法,并将我的对象空间传给self# 3. 执行具体的__init__代码,给对象空间封装属性# 操作对象中静态变量    # 1. __dict__ 查询对象中的所有内容    # 2. 万能的点 . print(ret.name)  # 查ret.high = 189  # 增del ret.faith  # 删除ret.age = 99  # 改# print(ret.__dict__)  # 对象操作类中的静态变量 : 只能查询# print(ret.mind)对象调用类中的方法 ( 工作中 通过对象执行类中的方法,而不是通过类名)# ret.shop()# print(ret)</code></pre><p>例子</p><pre><code>class Person:    mind = &#39;有思想的&#39;    animal = &#39;高级动物&#39;    faith = &#39;有信仰的&#39;    def __init__(self, name, age, hobby):        self.name = name        self.age = age        self.faith = hobby    def work(self):        print(&#39;%s是会工作的&#39; % self.name)    def shop(self):        print(&#39;%s会消费......&#39; % self.name)    def get(self):        print(&#39;%s今年%s岁了&#39; % (self.name, self.age))ret = Person(&#39;alex&#39;, 19, &#39;喝酒&#39;)# ret.work()# ret.shop()# ret.get()</code></pre><h3 id="二-面向对象-名称空间"><a href="#二-面向对象-名称空间" class="headerlink" title="二.面向对象-名称空间"></a>二.面向对象-名称空间</h3><p>1.创建一个类就会创建一个类的名称空间,用来存储类中定义的所有名字,这些名字称为类的属性</p><p>​        而类有两种属性:    静态属性和动态属性</p><p>​                                静态属性就是直接在类中定义的变量</p><p>​                                动态属性就是定义在类中的方法</p><p>​        其中类的数据属性是共享给所有对象的</p><pre><code>&gt;&gt;&gt;id(egg.role)4341594072 # 内存地址&gt;&gt;&gt;id(Person.role)4341594072</code></pre><p>​        而类动态属性是绑定到所有对象的</p><pre><code>&gt;&gt;&gt;egg.attack&lt;bound method Person.attack of &lt;__main__.Person object at 0x101285860&gt;&gt;&gt;&gt;&gt;Person.attack&lt;function Person.attack at 0x10127abf8&gt; </code></pre><h4 id="创建一个对象-实例就会创建一个对象-实例的名称空间-存放对象-实例的名字-称为对象-实例的属性"><a href="#创建一个对象-实例就会创建一个对象-实例的名称空间-存放对象-实例的名字-称为对象-实例的属性" class="headerlink" title="创建一个对象/实例就会创建一个对象/实例的名称空间, 存放对象/实例的名字.  称为对象/实例的属性"></a>创建一个对象/实例就会创建一个对象/实例的名称空间, 存放对象/实例的名字.  称为对象/实例的属性</h4><p>在obj.name 会先从obj 自己的名称空间找 name  .找不到则去类中找,再找不到就去父类中扎找…最好找不到就会抛出异常</p><ol start="2"><li>查询顺序:<ol><li>对象.属性:  先从对象空间找.如果找不到.再从类空间找.再找不到.再从父类中找..</li><li>类名.属性:  先从本类空间中找.如果找不到,在从父类中找..</li></ol></li><li>对象与对象之间是相互独立的</li></ol><pre><code>计算一个类 实例化多少对象.class Count:    count = 0    def __init__(self):        Count.count = self.count + 1obj1 = Count()obj2 = Count()print(Count.count)count = 0def func():    print(count)func()class Count:    count = 0    def __init__(self):        pass通过类名可以更改我的类中的静态变量值Count.count = 6print(Count.__dict__)但是通过对象 不能改变只能引用类中的静态变量obj1 = Count()print(obj1.count)obj1.count = 6</code></pre><h3 id="三-组合-给一个类的对象封装一个属性-这个属性是另一个类的对象"><a href="#三-组合-给一个类的对象封装一个属性-这个属性是另一个类的对象" class="headerlink" title="三.组合: 给一个类的对象封装一个属性,这个属性是另一个类的对象"></a>三.组合: 给一个类的对象封装一个属性,这个属性是另一个类的对象</h3><pre><code>class GameRole:    def __init__(self, name, ad, hp):        self.name = name        self.ad = ad        self.hp = hp    def attack(self,p):        p.hp = p.hp - self.ad        print(&#39;%s 攻击 %s,%s 掉了%s血,还剩%s血&#39; %(self.name,p.name,p.name,self.ad,p.hp))    def armament_weapon(self,wea):        self.wea = weaclass Weapon:    def __init__(self,name,ad):        self.name = name        self.ad = ad    def fight(self,p1,p2):        p2.hp = p2.hp - self.ad        print(&#39;%s 用%s打了%s,%s 掉了%s血,还剩%s血&#39;\              % (p1.name,self.name,p2.name,p2.name,self.ad,p2.hp))p1 = GameRole(&#39;大阳哥&#39;,20,500)p2 = GameRole(&#39;印度阿宁&#39;,50,200)axe = Weapon(&#39;三板斧&#39;,60)broadsword = Weapon(&#39;屠龙宝刀&#39;,100)# print(axe)p1.armament_weapon(axe)  # 给大阳哥 装备了三板斧这个对象.# print(p1.wea)# print(p1.wea.name)# print(p1.wea.ad)p1.wea.fight(p1,p2)</code></pre><h3 id="四-面向对象第一大特性—继承"><a href="#四-面向对象第一大特性—继承" class="headerlink" title="四.面向对象第一大特性—继承"></a>四.面向对象第一大特性—继承</h3><ol><li><p>子类以及子类实例化的对象, 可以访问父类的任何方法和变量</p></li><li><p>类名可以访问父类的所有内容 (print(Animal.breath))</p></li><li><p>子类实例化的对象也可以访问父类所有内容 print(p1.breath) print(p1) p1.eat()</p></li><li><p>只执行父类的方法: 子类中不要定义与父类同名的方法</p></li><li><p>只执行子类的方法,在子类中创建</p></li><li><p>既要执行子类的方法,又要执行父类中的方法?</p><ol><li><p>两种办法:</p><pre><code>Animal.__init__(self, name, sex, age)super().__init__(name,sex,age)</code></pre></li></ol></li></ol><pre><code>class Animal:    breath = &#39;呼吸&#39; # 静态字段    def __init__(self,name,sex,age)        self.name = name        self.sex = sex        self.age = age    def eat(self):        print(&#39;吃东西...&#39;)class Cat(Animal): # 括号里面的: 父类,基类,超类 括号外面的: 子类,派生类    passclass Dog(Animal):    passp1 = Cat(&#39;alex&#39;,&#39;women&#39;,100)    # 实例化子类对象print(p1.__dict__)</code></pre><pre><code>class Animal:    def __init__(self, name, sex, age):        self.name = name        self.sex = sex        self.age = age    def eat(self, a):        print(&#39;%s吃%s&#39; % (self.name, a))    def drink(self):        print(&#39;%s喝东西&#39; % self.name)class Cat(Animal):    def __init__(self, name, sex, age, wing):        Animal.__init__(self, name, sex, age)        # super(Cat, self).__init__(name, sex, age)        self.wing = wing    def miaow(self):        print(&#39;喵喵叫&#39;)    def eat(self, a):        super(Cat, self).eat(a)        print(666)c1 = Cat(&#39;tom&#39;, &#39;公&#39;, 3, &#39;好看&#39;)# print(c1.__dict__)c1.eat(&#39;金蝉&#39;)</code></pre><h3 id="五-继承的进阶"><a href="#五-继承的进阶" class="headerlink" title="五.继承的进阶"></a>五.继承的进阶</h3><p>​    1.继承: 单继承, 多继承</p><p>​    2.类的角度: A–&gt;经典类,B–&gt;新式类</p><p>​        1.新式类: 凡是继承object类都是新式类( 在Python3版本中,所有类都是新式类,因为Python3版本中的类都默认继承object)</p><p>​        2.经典类: 不继承object类的都是经典类(Python2中既有新式类又有经典类,中所有的类都不继承object,所以所有的类默认是经典类)</p><p>​    3.单继承: 新式类,经典类查询顺序一样</p><pre><code>class A:    def func(self):        print(&#39;A&#39;)class B(A):    def func(self):        print(&#39;B&#39;)class C(B):    def func(self):        print(&#39;C&#39;)c1 = C()c1.func()b1 = B()b1.func()</code></pre><p>​    4.多继承:</p><p>​        1.新式类: 遵循广度优先</p><p>​        2.多继承的新式类 广度优先:  一条路都到倒数第二级,进行判断,如果其他路能走到终点,则返回走另外一条路,如果不能,则走到终点</p><p><img src="C:\Users\付举鹏\AppData\Roaming\Typora\typora-user-images\1603693720711.png" alt="1603693720711"></p><p>​        </p><pre><code>class A:    def func(self):        print(&#39;IN A&#39;)class B(A):    pass    # def func(self):    #     print(&#39;IN B&#39;)class C(A):    pass    # def func(self):    #     print(&#39;IN C&#39;)class D(B):    pass    # def func(self):    #     print(&#39;IN D&#39;)class E(C):    pass    # def func(self):    #     print(&#39;IN E&#39;)class F(D, E):    pass    # def func(self):    #     print(&#39;IN F&#39;)f1 = F()f1.func()print(F.mro())  # 查询类的继承顺序</code></pre><p>​        3.经典类: 遵循深度优先:  一条路走到底</p><h3 id="六-面向对象之封装和多态"><a href="#六-面向对象之封装和多态" class="headerlink" title="六.面向对象之封装和多态"></a>六.面向对象之封装和多态</h3><p>​    一. 接口类,抽象类: 制定一个规范(Python中没有接口的概念)</p><p>​        </p><pre><code># 制定规则,抽象类,接口类from abc import ABCMeta, abstractmethodclass Payment(metaclass=ABCMeta):  # 抽象类(接口类)    @abstractmethod  # 装饰器    def pay(self): pass  # 制定规范class Alipay(Payment):    def __init__(self, money):        self.money = money    def pay(self):        print(&#39;使用了支付宝支付了%s&#39; % self.money)class Jdpay(Payment):    def __init__(self, money):        self.money = money    def pay(self):        print(&#39;使用了京东支付了%s&#39; % self.money)def pay(obj):    obj.pay()a1 = Alipay(1000)p1 = Jdpay(1222)pay(a1)  # 归一化设计pay(p1)</code></pre><p>​    二. 多态</p><p>​        1.多态: Python中没有多态,只有鸭子类型(Python是弱类型语言,不管是什么类型,传入函数,封装到对象中都可以)</p><p>​        以下这些类互称为鸭子</p><pre><code>class Str:    def index(self):        passclass List:    def index(self):        passclass Tuple:    def index(self):        pass</code></pre><p>​    三.封装</p><p>​        1.广义的封装: 实例化一个对象, 给对象空间封装一些属性</p><p>​        2.狭义的封装: 私有制</p><p>​        3.私有成员:  私有静态字段,私有方法,私有对象属性</p><p>​        </p><p>​        A.私有静态字段</p><p>​        </p><pre><code>class A:    __money = 1100  # 前面加 __就是私有静态字段class B(A):    name = &#39;alex&#39;    __age = 99  # 前面加 __就是私有静态字段    def func(self):        print(self.__age)  # 对于私有静态字段,类的内部是可以访问的        print(B.__age)        # print(self.__money)        print(&#39;func...&#39;)a1 = B()print(a1.name)print(a1.name)print(a1.__age)  # 实例化对象不能访问私有静态字段print(B.__age)  # 类名也不能访问私有静态字段                #对与私有静态字段,类的外部是不能访问的a1.func()#对于私有静态字段,只能在类的内部访问,类的外部,派生类均不能访问#其实是可以访问的是Python中的一个bug(工作中千万不要用)print(B._B__age)print(B.__dict__)</code></pre><p>​        B.私有方法</p><pre><code>#私有方法class B:    __money = 1000  #前面加 __就是私有静态字段    def __f1(self):  #前面加 __就是私有方法        print(&#39;B&#39;)class A(B):    name = &#39;alex&#39;    def __func(self):        print(&#39;func...&#39;)    def func1(self):        self.__func()  # 类的内部可以访问        self.__f1()a1 = A()# a1.__func()  # 类的外部不能访问a1.func1()  # 类的内部可以访问a1.func1()  # 类的派生类不可以访问</code></pre><h3 id="七-面向对象之反射-重点"><a href="#七-面向对象之反射-重点" class="headerlink" title="七.面向对象之反射(重点)"></a>七.面向对象之反射(重点)</h3><p> 1.反射:  用字符串数据类型的变量名来访问这个变量的值</p><p> 2.反射的方法: getattr hasattr setattr  delattr</p><ul><li>命名空间.xxx = getattr(命名空间, ‘xxx’)</li></ul><p>​    1.反射类  –&gt;  静态属性  类方法  静态方法</p><pre><code>s Student:    role = &#39;student&#39;    @classmethod    def check_course(cls):        print(&#39;查看课程&#39;)    @staticmethod    def login():        print(&#39;登录&#39;)# 反射查看属性print(Student.role)print(hasattr(Student, &#39;role&#39;))  # 结果是Trueprint(getattr(Student, &#39;role&#39;))# 反射调用方法getattr(Student, &#39;check_course&#39;)()  # 类方法getattr(Student, &#39;login&#39;)()  # 静态方法num = input(&#39;&gt;&gt;&gt;&#39;)if hasattr(Student, num):    getattr(Student, num)()</code></pre><p>​    2.对象的反射 –&gt; 方法  对象属性</p><pre><code>class A:    def __init__(self, name):        self.name = name    def func(self):        print(&#39;in func&#39;)a = A(&#39;alex&#39;)print(a.name)# 反射对象属性print(hasattr(a, &#39;name&#39;))print(getattr(a, &#39;name&#39;))# 反射对象方法getattr(a, &#39;func&#39;)()</code></pre><p>​    3.模块的反射</p><pre><code>mport os   # 别人写好的python代码的结合# os.rename(&#39;__init__.py&#39;, &#39;init&#39;)# getattr(os, &#39;rename&#39;)(&#39;nit&#39;, &#39;__init__.py&#39;)  # == os.namerename = os.renamerename1 = getattr(os, &#39;rename&#39;)# rename1(&#39;__init__.py&#39;, &#39;init&#39;)  # os.rename(__init__.py&#39;, &#39;init&#39;) rename(&#39;init&#39;, &#39;__init__.py&#39;)  # os.rename(&#39;init&#39;, &#39;__init__.py&#39;)</code></pre><p>​        1.反射自己模块中的内容</p><pre><code># 反射自己模块中的内容, 找到自己当前文件所在的命名空间def wahaha():    print(&#39;哈哈哈&#39;)def qqing():    print(&quot;123&quot;)import sys# print(sys.modules)# import 相当于导入了一个模块# 模块哪个导入了, 哪个没导入, 在自己的python解释器里面应该记录下来# import sys 是一个模块, 这个模块里的所有的方法都是和python解释器相关的# sys.modules 这个方法, 表示所有在当前这个python程序中导入的模块# &#39;__main__&#39;:&lt;module &#39;__main__&#39; from &#39;D:/sylar/python_workspace/day20/4.反射.py&#39;&gt;print(sys.modules[&#39;__main__&#39;])my_file = sys.modules[&#39;__main__&#39;]my_file.wahaha()my_file.qqing()getattr(my_file, &#39;wahaha&#39;)()</code></pre><ul><li>反射<ul><li>hasattr getattr</li><li>类名.名字<ul><li>getattr(类名, ‘名字’)</li></ul></li><li>对象名.名字<ul><li>getattr(对象, ‘名字’)</li></ul></li><li>模块名<ul><li>getattr(模块, ‘名字’)</li></ul></li><li>自己文件.名字<ul><li>import sys</li><li>getattr(sys.modules[‘_ <em>main</em> _ _’], ‘名字’) </li></ul></li></ul></li></ul><h4 id="选课系统的代码"><a href="#选课系统的代码" class="headerlink" title="选课系统的代码"></a><em>选课系统的代码</em></h4><pre><code>class Manager:    OPERATE_DIC = [        (&#39;创建学生账号&#39;, &#39;create_student&#39;),        (&#39;创建课程&#39;, &#39;create_course&#39;),        (&#39;查看学生信息&#39;, &#39;check_student_info&#39;)    ]    def __init__(self, name):        self.name = name    def create_student(self):        print(&#39;创建学生账号&#39;)    def create_course(self):        print(&#39;创建课程&#39;)    def check_student_info(self):        print(&#39;查看学生信息&#39;)class Student:    OPERATE_DIC = [        (&#39;查看课程&#39;, &#39;check_course&#39;),        (&#39;选择课程&#39;, &#39;choose_course&#39;),        (&#39;查看已经选择的课程&#39;, &#39;choosed_course&#39;)    ]    def __init__(self, name):        self.name = name    def check_course(self):        print(&#39;查看课程&#39;)    def choose_course(self):        print(&#39;选择课程&#39;)    def choosed_course(self):        print(&#39;查看已经选择的课程&#39;)def login():    username = input(&#39;user: &#39;)    password = input(&#39;pwd: &#39;)    with open(&#39;userinfo&#39;) as f1:        for line in f1:            user, pwd, ident = line.strip().split(&#39;|&#39;)            if user == username and pwd == password:                print(&#39;登录成功...&#39;)                return username, identimport sysdef main():    usr, id = login()    file = sys.modules[&#39;__main__&#39;]    cls = getattr(file, id)    obj = cls(usr)    operate_dic = cls.OPERATE_DIC    while True:        for num, i in enumerate(operate_dic, 1):            print(num, i[0])        choice = int(input(&#39;请选择:&#39;))        print(len(operate_dic))        if choice &lt; len(operate_dic):            choice_item = operate_dic[choice - 1]            getattr(obj, choice_item[1])()        else:            print(&#39;输入有误,重新输入:&#39;)main()</code></pre><h3 id="八-面向对象的进阶"><a href="#八-面向对象的进阶" class="headerlink" title="八.面向对象的进阶"></a>八.面向对象的进阶</h3><ul><li><p>析构方法</p><ul><li>释放一个空间之前执行</li><li>某对象借用了操作系统的资源, 还要通过析构方法归还回去:  比如–&gt; 文件资源, 网络资源</li></ul><p>1.垃圾回收机制</p></li></ul><pre><code>class A:    def __del__(self):        # 析构方法 del A的对象, 会自动触发这个方法        print(&#39;执行我来了&#39;)a = A()del a  # 对象的删除, delprint(a)class File:    def __init__(self, file_path):        self.f = open(file_path)        self.name = &#39;alex&#39;    def read(self):        self.f.read(1024)    def __del__(self):  # 是去归还/释放一些在创建对象的时候借用的一些资源        # del 对象的时候 是程序员触发        # python 解释器的垃圾回收机制, 回收这个对象所占的内存的时候, python自动触发的        self.close()f = File(&#39;文件名&#39;)f.read()# 不管是主动还是被动, 这个f对象总会被清理掉, 被清理掉就会触发__del__方法, 触发这个方法就会归还操作系统的文件资源# python解释器在内部就能搞定的事# 申请一块空间, 是操作系统分配给你的# 在这一块空间中, 是由python解释器来管理的# example :  f = open(&#39;文件&#39;)  # python--&gt; 操作系统 --&gt; 硬盘里的文件 --&gt; 文件操作符f.close()  # f就是文件操作符# def f</code></pre><ul><li>item系列 是和对象使用[] 访问值有联系<ul><li>在内置模块中,有一些特殊的方法, 要求对象必须实现_ _ getitem _ _/ _ _ setitem _ _ 才能使用</li></ul></li></ul><pre><code>class A:    def __getitem__(self, item):        return getattr(self, item)    def __setitem__(self, key, value):        setattr(self, key, value*2)    def __delitem__(self, key):        delattr(self, key)a = A()a.k1 = &#39;k1&#39;print(a.k1)a[&#39;k1&#39;] = &#39;v1&#39;  # 默认调用 __setitem 方法print(a[&#39;k1&#39;])  # 默认调用 __getitemdel a[&#39;k1&#39;]  # 默认调用__delitemprint(a[&#39;k1&#39;]) class B:    def __init__(self, lst):        self.lst = lst    def __getitem__(self, item):        return self.lst[item]    def __setitem__(self, key, value):        self.lst[key] = value    def __delitem__(self, key):        self.lst.pop(key)b = B([&#39;111&#39;, &#39;22&#39;, &#39;dd&#39;, &#39;rr&#39;])print(b.lst[0])print(b[0])b[2] = &#39;alex&#39;print(b[2])print(b.lst)del b[2]print(b.lst)</code></pre><ul><li><p>hash方法</p><ul><li>底层数据结构是基于hash值寻址的优化</li><li>hash 是一个算法</li><li>能够把某一个要存在内里的值通过一系列的计算</li><li>‘adf’ – &gt; 851621 类似于这样</li><li>对同一个值在多次执行python代码的时候值是不同的</li><li>但是同一个值, 在同一次执行python代码的时候hash值 永远不变</li><li>字典的寻址 – hash 算法 通过key的hash值去找value,所以速度比较快</li><li>d = {‘key’ : ‘value’}</li><li>hash 是一个内置函数</li><li>hash(obj)  # obj内部必须是实现了_ _ hash _ _ 方法</li><li>set集合  hash不是万能的, 两个不一样的字符串, hash值可能相等–&gt; 如果hash值相等,首先它就会判断值是否相等 == ,相同则去重, 不同则存在内存中</li><li>set集合的去重原理–&gt; 通过hash算法去重的, hash的结果找到一块内存地址,只要这个地址上没有数据,就说明之前没有重复的数据, 如果这块地址上有一个数据存在了,才判断这个值和我要存的值是否一样, 如果一样,覆盖去重, 如果不一样,二次寻址给这个值换个地方存</li></ul></li><li><p>eq方法</p></li></ul><pre><code>class A:    def __init__(self, name, age):        self.name = name        self.age = age    def __eq__(self, other):        if self.name == other.name and self.age == other.age:            return Truea = A(&#39;LAEX&#39;, 10)a1 = A(&#39;LAEX&#39;, 10)a2 = A(&#39;LAEX&#39;, 10)a3 = A(&#39;LAEX&#39;, 10)print(a, a1,)print(a == a1 == a2)  # 返回True 完全和__eq__方法一样</code></pre><ul><li>一道经典面试题</li></ul><pre><code># 一个类# 对象的属性: 姓名 性别 年龄 部门# 员工管理系统# 内部转岗 python--go开发# alex male 44 python# alex male 55 go# 1000个员工# 如果几个员工对象的姓名和性别相同,这是一个人# 请对这1000个员工做去重class Employee:    def __init__(self, name, sex, age, partment):        self.name = name        self.sex = sex        self.age = age        self.partment = partment    def __hash__(self):  # 第二步 ,重写父类boject的__hash__方法, 返回hash的值,还是不行        return hash(&#39;%s%s&#39; % (self.name, self.sex))    def __eq__(self, other):  # 第三步, 重写__eq__方法 ,判断值是否相等,返回True        if self.name == other.name and self.sex == other.sex:            return Trueemploy_lst = []for i in range(100):    employ_lst.append(Employee(&#39;alex&#39;, &#39;male&#39;, i, &#39;python&#39;))for i in range(100):    employ_lst.append(Employee(&#39;wusir&#39;, &#39;male&#39;, i, &#39;go&#39;))employ_set = set(employ_lst)  # 第一步,先用set集合去重,结果不行# print(employ_lst)for person in employ_set:    print(person.__dict__)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面向对象初始 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/10/03/Python%E7%94%9F%E6%88%90%E5%99%A8,%E9%97%AD%E5%8C%85/"/>
      <url>/2020/10/03/Python%E7%94%9F%E6%88%90%E5%99%A8,%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="一-函数名的运用"><a href="#一-函数名的运用" class="headerlink" title="一. 函数名的运用"></a>一. 函数名的运用</h3><ul><li>函数名的内存地址</li></ul><pre><code>def func():    print(&quot;呵呵&quot;)print(func)结果:&lt;function func at 0x1101e4ea0&gt;</code></pre><p>1.函数名可以赋值给其他变量</p><pre><code>def func():    print(&quot;123&quot;)print(func)a = func    #把函数当成一个变量赋值给另一个变量a() # 函数调用func()</code></pre><p>2.函数名可以当做容器类的元素(列表 lst)</p><pre><code>def func1():    print(&quot;hehe&quot;)def func2():    print(&quot;hehe&quot;)def func3():    print(&quot;hehe&quot;)lst = [func1,func2,func3]for i in lst:    i()</code></pre><p>3.函数名可以当做函数的参数</p><pre><code>def func():    print(&quot;123&quot;)def func1(fn):    print(&quot;我是func2&quot;)    fn()    #执行传递过来的fn    print(&quot;这里是函数1&quot;)func2(func) #把函数func当成参数传递func2的参数fn</code></pre><p>4.函数名可以作为函数的返回值</p><pre><code>def func_1():    print(&quot;这⾥是函数1&quot;)    def func_2():    print(&quot;这⾥是函数2&quot;)    print(&quot;这⾥是函数1&quot;)    return func_2fn = func_1() # 执⾏函数1. 函数1返回的是函数2, 这时fn指向的就是上⾯函数2fn() </code></pre><h3 id="二-闭包"><a href="#二-闭包" class="headerlink" title="二. 闭包"></a>二. 闭包</h3><ul><li>闭包就是内层函数对外层函数 (非全局) 的变量的引用</li><li>内部函数访问外部函数的局部变量</li><li>我们可以使用<strong>closure__来检测函数是否是闭包,使用函数名__closure</strong> 返回cell 就是闭包,返回None就不是闭包</li></ul><pre><code>def func1():    name = &quot;alex&quot;     #常驻内存,防止其他程序改变这个变量    def func2():        print(name)    #在内层函数中调用了外层函数的变量,叫闭包,可以让局部变量常驻内存    return func2ret= func1()ret() #执行的就是func2结果:alex</code></pre><ul><li><p>闭包的好处</p><p>1.安全</p><p>2.常驻内存,提高效率</p></li></ul><pre><code>from urllib.request import urlopendef but():    content = urlopen(&quot;http://www.h3c.com/cn/&quot;).read()    def inner():        return content  # 再函数内部使用了外部的变量.闭包    #print(inner.__closure__) #查看inner是否是闭包,有东西就是闭包,返回None 就不是闭包    return innerfn = but()content = fn() #获取内容print(content)content1 = fn() #重新获取内容print(content1)</code></pre><h3 id="三-迭代器"><a href="#三-迭代器" class="headerlink" title="三. 迭代器"></a>三. 迭代器</h3><p>​    1.可迭代对象(Iterable): 内部包含<strong>iter</strong> () 方法</p><p>​    2.迭代器(Iterator): 内部包含<strong>iter</strong>() <strong>next</strong>()</p><p>​    3.可迭代对象: str list tuple set f文件句柄 dict</p><p>​    4.可以使用dir函数来查看类中定义好的方法</p><pre><code>s = &quot;哈哈哈&quot;print(dir(s)) #可以打印对象中的方法和函数print(dir(str)) #也可以打印类中声明的方法和函数打印结果中如果有__iter__()函数 则表示是可迭代对象</code></pre><pre><code># 模拟for 循环lst = [&quot;as&quot;, &quot;aa&quot;, &quot;bb&quot;]it = lst.__iter__()  # 拿到迭代器while 1:    try:        name = it.__next__()  # 拿元素        print(name)    except StopIteration:  # 拿完了        break</code></pre><pre><code>lst = [1,2,3]from collections.abc import Iterable #可迭代的 #记得加abc 不然会有warningfrom collections.abc import Iterator #迭代器#isintance (对象,类型) 判断xx对象是否是xx类型的print(isinstance(lst,Iterable))print(isinstance(lst,Iterator))it = lst.__iter__() #获取迭代器print(isinstance(it,Iterable)) #判断是否可迭代的,迭代器一定是可迭代的print(isinstance(it,Iterator)) #迭代器里面一定有 __iter__() 和 __next__()print(&quot;__iter__&quot;in dir(lst)) #确定是一个可迭代的print(&quot;__next__&quot; in dir(lst)) #确定不是一个迭代器f = open(&quot;今日内容大纲&quot;,mode=&quot;r&quot;,encoding=&quot;utf-8&quot;) # 文件句柄 是可迭代的也是一个迭代器print(isinstance(f,Iterable))print(isinstance(f,Iterator))</code></pre><ul><li>用isintance(对象,类型) 来判断对象是否是什么类型</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><p>​    iterable : 可迭代对象,内部包含<strong>iter</strong>()函数</p><p>​    iterator : 迭代器 内部包含<strong>iter</strong>() 和<strong>next</strong>() 函数</p><ul><li><p>迭代器的特点:</p><p>1.节省内存</p><p>​    2.惰性机制</p><p>​        3.不能反复,只能向下执行</p></li></ul><h3 id="四-生成器和生成器表达式"><a href="#四-生成器和生成器表达式" class="headerlink" title="四.生成器和生成器表达式"></a>四.生成器和生成器表达式</h3><p>​    1.生成器</p><p>​        生成器的本质就是迭代器</p><p>​        在Python中有三种方式来获取生成器:1.通过生成器函数 2.通过各种推导式来实现生成器 3.通过数据的转换也可以获取生成器</p><ul><li>简单的example</li></ul><pre><code>def func():    print(&quot;我是:&quot;)    yield &quot;99&quot; #当函数中有了yield 就不是普通的函数了,是生成器函数    print(&quot;你是?&quot;)    yield &quot;88&quot;    print(&quot;它是?&quot;)    yield &quot;77&quot;    print(&quot;6666?&quot;) #最后一个yield之后如果还执行__next__() 就会报错g = func() # 拿到的是生成器.生成器的本质是迭代器,迭代器可以被迭代,生成器直接可以 for 循环 print(g.__next__())</code></pre><p>​    return 直接返回结果,结束函数的调用</p><p>​    yield 返回结果, 可以让函数分段执行</p><pre><code>def func():    yield 11    yield 13    yield 12g = func() # 拿到的是生成器. 生成器的本质是迭代器. 迭代器可以被迭代 生成器可以直接for循环.for i in g:    print(i)  # 本质上执行的是 __next__()it = g.__iter__()while 1:    try:        print(it.__next__())    except StopIteration:        break</code></pre><p>​    send() 方法</p><pre><code>def eat():    print(&quot;我吃什么啊&quot;)    a = yield &quot;馒头&quot;    print(&quot;a=&quot;,a)    b = yield &quot;⼤饼&quot;    print(&quot;b=&quot;,b)    c = yield &quot;⾲菜盒⼦&quot;    print(&quot;c=&quot;,c)    yield &quot;GAME OVER&quot;gen = eat() # 获取⽣成器ret1 = gen.__next__()print(ret1)ret2 = gen.send(&quot;胡辣汤&quot;)print(ret2)ret3 = gen.send(&quot;狗粮&quot;)print(ret3)ret4 = gen.send(&quot;猫粮&quot;)print(ret4)</code></pre><p>send() 和 <strong>next</strong>()的区别:</p><pre><code>1. send 和 next() 都是让生成器向下走一次 2. send 可以给上一个yield的位置传递参数, 不能给最后一个yield发送值,在第一次执行生成器的时候不能使用send()</code></pre><p>​    4.生成器表达式</p><p>​        生成器表达式和列表推导式差不多 只是把[] 替换成()</p><pre><code>gen = (i for i in range(18))print(gen)结果: &lt;generator object &lt;genexpr&gt; at 0x106768f10&gt;</code></pre><p>​        打印的结果就是一个生成器, 我们可以使用 for 循环 来循环这个生成器:</p><pre><code>gen = (&quot;麻花藤我第%s次爱你&quot; % i for i in range(10))for i in gen:    print(i)</code></pre><p>​        生成器表达式可以进行筛选:</p><p>​    </p><pre><code># 获取1-100内能被3整除的数gen = (i for i in range(1,100) if i % 3 == 0)for num in gen:     print(num)# 100以内能被3整除的数的平⽅gen = (i * i for i in range(100) if i % 3 == 0)for num in gen:     print(num)# 寻找名字中带有两个e的⼈的名字names = [[&#39;Tom&#39;, &#39;Billy&#39;, &#39;Jefferson&#39;, &#39;Andrew&#39;, &#39;Wesley&#39;, &#39;Steven&#39;,&#39;Joe&#39;],         [&#39;Alice&#39;, &#39;Jill&#39;, &#39;Ana&#39;, &#39;Wendy&#39;, &#39;Jennifer&#39;, &#39;Sherry&#39;, &#39;Eva&#39;]]# 不⽤推导式和表达式result = []for first in names:     for name in first:         if name.count(&quot;e&quot;) &gt;= 2:             result.append(name)print(result)# 推导式gen = (name for first in names for name in first if name.count(&quot;e&quot;) &gt;= 2)for name in gen:     print(name)</code></pre><p>​        生成器表达式和列表推导式的区别:</p><p>​            1. 列表推导式比较耗内存,一次性加载, 生成器表达式几乎不占用内存, 使用的时候才分配和使用内存</p><p>​            2. 得到的值不一样, 列表推导式得到的一个列表 , 生成器表达式获取的是一个生成器</p><p>​        生成器的惰性的机制: 生成器只有在访问的时候才取值, 说白了 , 你找他要他才给值, 不找他,他不执行</p><pre><code>def func():     print(111)     yield 222g = func() # ⽣成器gg1 = (i for i in g) # ⽣成器g1. 但是g1的数据来源于gg2 = (i for i in g1) # ⽣成器g2. 来源g1print(list(g)) # 获取g中的数据. 这时func()才会被执⾏. 打印111.获取到222. g完毕.print(list(g1)) # 获取g1中的数据. g1的数据来源是g. 但是g已经取完了. g1 也就没有数据了print(list(g2)) # 和g1同理</code></pre><h2 id="深坑-gt-⽣成器-要值得时候才拿值"><a href="#深坑-gt-⽣成器-要值得时候才拿值" class="headerlink" title="深坑==&gt; ⽣成器. 要值得时候才拿值."></a>深坑==&gt; ⽣成器. 要值得时候才拿值.</h2><h3 id="五-推导式"><a href="#五-推导式" class="headerlink" title="五. 推导式"></a>五. 推导式</h3><p>​    1. 列表推导式</p><p>​        列表推导式的常用写法</p><p>​        [结果 for 变量 in 可迭代对象]</p><p>​        例. 从Python1 期到Python 141期 写入列表lst:</p><pre><code>lst = [&#39;python%s&#39; %i for i in rang(1,15)]print(lst)</code></pre><pre><code>lst = []for i in range(1,15):    lst.append(i)pirnt(lst)替换成列表推导式lst = [i for i in rang(1,15)]print(lst)</code></pre><p>​        列表推导式是通过一行来构建你要的列表, 列表推导式看起来代码简单,但出错后很难排查</p><p>​    2. 字典推导式(推导出来的字典)</p><pre><code># 把字典中的key和value互换dic = &#123;&#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;&#125;new_dic = &#123;dic[key]: key for key in dic&#125;print(new_dic)# 在以下list中. 从lst1中获取的数据和lst2中相对应的位置的数据组成⼀个新字典lst1 = [&#39;jay&#39;, &#39;jj&#39;, &#39;sylar&#39;]lst2 = [&#39;周杰伦&#39;, &#39;林俊杰&#39;, &#39;邱彦涛&#39;]dic = &#123;lst1[i]: lst2[i] for i in range(len(lst1))&#125;print(dic)</code></pre><p>​    </p><pre><code> 3. 集合推导式      1. 集合推导式可以帮我们直接生成一个集合, 集合的特点: 无序,不重复. 所以集合推导式自带去重功能</code></pre><pre><code>lst = [1, -1, 8, -8, 12]# 绝对值去重s = &#123;abs(i) for i in lst&#125;print(s)</code></pre><h3 id="总结-推导式-有-列表推导式-字典推导式-集合推导式-没有元组推导式"><a href="#总结-推导式-有-列表推导式-字典推导式-集合推导式-没有元组推导式" class="headerlink" title="总结: 推导式 有, 列表推导式,字典推导式, 集合推导式,没有元组推导式"></a>总结: 推导式 有, 列表推导式,字典推导式, 集合推导式,没有元组推导式</h3><p>​    生成器表达式: (结果 for 变量 in 可迭代对象 if 条件筛选)</p><p>​    生成器表达式可以直接获取生成器对象, 生成器对象可以直接进行 for 循环 生成器具有惰性机制</p><h3 id="六-难度系数很高的面试题"><a href="#六-难度系数很高的面试题" class="headerlink" title="六. 难度系数很高的面试题"></a>六. 难度系数很高的面试题</h3><pre><code>def add(a, b):    return a + bdef gen():    for r_i in range(4):         yield r_ig = gen()for n in [2, 10]:    g = (add(n, i) for i in g)print(list(g))</code></pre><p> 友情提⽰: 惰性机制, 不到最后不会拿值 </p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> 生成器·闭包 和各种推导式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/09/25/Python%E7%89%B9%E6%AE%8A%E6%80%BB%E7%BB%93/"/>
      <url>/2020/09/25/Python%E7%89%B9%E6%AE%8A%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一.冒泡排序"></a>一.冒泡排序</h3><pre><code># 冒泡排序lst = [11, 22, 35, 6, 2]for i in range(len(lst)):    i = 0    while i &lt; len(lst) - 1:        if lst[i] &gt; lst[i + 1]:            lst[i], lst[i + 1] = lst[i + 1], lst[i]    #解构        i += 1print(lst)</code></pre><h3 id="二-经典题1-文件al-txt内容-升级题"><a href="#二-经典题1-文件al-txt内容-升级题" class="headerlink" title="二.经典题1:文件al.txt内容(升级题)"></a>二.经典题1:文件al.txt内容(升级题)</h3><pre><code>序号  部门  人数  平均年龄    备注  描述1   python  30  26  单身狗 屌丝居多2   Linux   26  30  没对象 全是屌丝3   运营部 20  24  女生多 没有人通过代码,将其构建成这种数据类型:[&#123;&#39;序号&#39;:&#39;1&#39;,&#39;部门&#39;:Python,&#39;人数&#39;:30,&#39;平均年龄&#39;:26,&#39;备注&#39;:&#39;单身狗&#39;&#125;]f = open(&quot;a6.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)line = f.readline()lst = line.split()  # 第一行切割完成 key就准备完了result = []# 接着向后读取for lin in f:    ll = lin.split()    # 每一行都进行切割    dic = &#123;&#125;    for i in range(len(ll)):    # i 表示ll的索引\        # lst[i]    # key        # ll[i]        # value        dic[lst[i]] = ll[i]    result.append(dic)print(result)</code></pre><h3 id="三-三元运算符"><a href="#三-三元运算符" class="headerlink" title="三.三元运算符"></a>三.三元运算符</h3><pre><code>a = 1b = 2h = a if a&gt;b else bprint(h)</code></pre><h3 id="四-Python中递归-层数"><a href="#四-Python中递归-层数" class="headerlink" title="四.Python中递归 层数"></a>四.Python中递归 层数</h3><pre><code>在Python中递归层数最多998</code></pre><h3 id="五-用迭代器模拟for-循环"><a href="#五-用迭代器模拟for-循环" class="headerlink" title="五.用迭代器模拟for 循环"></a>五.用迭代器模拟for 循环</h3><pre><code>lst = [1,2,3,4]it = lst.__iter__()  # 获取迭代器while 1:    try:        name = it.__next__()  # 获取内容        print(name)    except StopIteration:  # 抛异常        break</code></pre><h3 id="六-接收n-个参数-返回最大值-和-最小值-字典"><a href="#六-接收n-个参数-返回最大值-和-最小值-字典" class="headerlink" title="六. 接收n 个参数, 返回最大值 和 最小值(字典)"></a>六. 接收n 个参数, 返回最大值 和 最小值(字典)</h3><pre><code>def func(*args):    ma = args[0]  # 假设第0项就是最大值    mi = args[0]  # 假设第0项就是最小值    for el in args:        if el &gt; ma:            ma = el  # 当前这个元素比假设的那个大,进行赋值        if el &lt; mi:            mi = el    return &#123;&quot;最大值&quot;: ma, &quot;最小值&quot;: mi&#125;ret = func(123,42, 22, 545, 21)print(ret)</code></pre><h3 id="七-经典题"><a href="#七-经典题" class="headerlink" title="七. 经典题"></a>七. 经典题</h3><pre><code>user_list=[        &#123;&quot;name&quot;: &quot;alex&quot;, &quot;hobby&quot;: &quot;抽烟&quot;&#125;,        &#123;&quot;name&quot;: &quot;alex&quot;, &quot;hobby&quot;: &quot;喝酒&quot;&#125;,        &#123;&quot;name&quot;: &quot;alex&quot;, &quot;hobby&quot;: &quot;烫头&quot;&#125;,        &#123;&quot;name&quot;: &quot;wusir&quot;, &quot;hobby&quot;: &quot;喊麦&quot;&#125;,        &#123;&quot;name&quot;: &quot;wusir&quot;, &quot;hobby&quot;: &quot;街舞&quot;&#125;,        &#123;&quot;name&quot;: &quot;alex&quot;, &quot;hobby&quot;: &quot;泡吧&quot;&#125;,        &#123;&quot;name&quot;:&quot;太白&quot;, &quot;hobby&quot;:&quot;开车&quot;&#125;         ]# [&#123;&quot;name&quot;: &quot;alex&quot;, &quot;hobby_list&quot;: [&quot;抽烟&quot;,&quot;喝酒&quot;,&quot;烫头&quot;,&quot;泡吧&quot;]&#125;,&#123;&quot;name&quot;: &quot;wusir&quot;, &quot;hobby_list&quot;: [&quot;喊麦&quot;, &quot;街舞&quot;]&#125;,]result = [] # &#123;&#39;name&#39;: &#39;alex&#39;, &#39;hobby_list&#39;: [&#39;抽烟&#39;]&#125;for user in user_list:    # 1.判断是否在result里面存在了这个人, 如果存在. 把hobby_list添加一个hobby    # 2.不存在. 创建一个新字典    # 3.第一次循环user_lsit result[] 为空 所以直接创建dic&#123;&#125; 执行else    for new_user in result:        if user[&#39;name&#39;] == new_user[&#39;name&#39;]:            new_user[&#39;hobby_list&#39;].append(user[&#39;hobby&#39;])            break    else:        dic = &#123;&#125;        dic[&quot;name&quot;] = user[&#39;name&#39;]        dic[&#39;hobby_list&#39;] = [user[&#39;hobby&#39;]]        result.append(dic)print(result)</code></pre><h3 id="八-深浅拷贝"><a href="#八-深浅拷贝" class="headerlink" title="八.深浅拷贝"></a>八.深浅拷贝</h3><pre><code>import copy赋值l1 = [1, 2, 3, [1, 4, 5]]l2 = l1  # = 是赋值, 数据完全共享,不管改哪个, 两个列表的值都会变l2[0] = &#39;alex&#39;print(l1)  # [&#39;alex&#39;, 2, 3, [1, 4, 5]]print(l2)  # [&#39;alex&#39;, 2, 3, [1, 4, 5]]浅拷贝l1 = [1, 2, 3, [1, 4, 5]]l2 = copy.copy(l1)  # 浅拷贝, 数据半共享,只改变列表的第一层,第二层不变l1[0] = &#39;alex&#39;# l2[0] = &#39;alex&#39;print(l1)  # [&#39;alex&#39;, 2, 3, [1, 4, 5]]print(l2)  # [1, 2, 3, [1, 4, 5]]深拷贝l1 = [1, 2, 3, [1, 4, 5]]l2 = copy.deepcopy(l1)  # 深拷贝, 数据完全不共享,互相没有影响l1[0] = &#39;alex0&#39;l2[3][0] = &#39;alex&#39;print(l1, l2)  # [&#39;alex0&#39;, 2, 3, [1, 4, 5]] [1, 2, 3, [&#39;alex&#39;, 4, 5]]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python中的重要总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/09/22/Python%E5%87%BD%E6%95%B0/"/>
      <url>/2020/09/22/Python%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="一、函数的定义"><a href="#一、函数的定义" class="headerlink" title="一、函数的定义"></a>一、函数的定义</h4><p>​    对代码块和功能的封装和定义</p><h3 id="二、函数的定义语法"><a href="#二、函数的定义语法" class="headerlink" title="二、函数的定义语法"></a>二、函数的定义语法</h3><p>​    </p><pre><code>def 函数名():    函数体def yue():    print(&quot;123&quot;)</code></pre><ul><li><p>函数的调用：使用函数名可以调用函数，写法：函数名()，这个时候函数体就会被执行</p><pre><code>yue()</code></pre><p>执行过程</p><p><img src="C:\Users\付举鹏\Desktop\Python学习截图\3.PNG"></p></li></ul><ul><li><p>函数的返回</p><p>执行完函数之后，我们可以使用return来返回结果</p><p>1.函数中遇到return，此函数结束，不再继续执行</p><pre><code>def yue(): print(&quot;约你&quot;) print(&quot;约我&quot;) print(&quot;约他&quot;) return print(&quot;约谁呀&quot;) # 这句话不会被执⾏yue()</code></pre><p>2.给函数的调用者一个访问结果</p><pre><code>def yue(): print(&quot;约你&quot;) print(&quot;约我&quot;) print(&quot;约他&quot;) return &quot;美⼥⼀枚&quot;girl = yue()print(girl) # 美⼥⼀枚</code></pre><p>3.函数的返回值可以是多个</p><pre><code>def yue():    print(&quot;123&quot;)    print(&quot;345&quot;)    return&quot;第一个结果&quot;,&quot;第二个结果&quot;girl = yue()print(type(girl))    #类型是tuple</code></pre></li><li><p>总结一下</p><p>1.遇到return，此函数结束，函数后面的东西不会被执行</p><p>2.return返回值：</p><p>​    如果return什么都不写 或者干脆不写return，那么返回值是None</p><p>​    如果return后面写了一个值，则调用者可以接受到一个结果</p><p>​    如果return后面写了多个值，则调用者可以接收一个tuple，调用者可以直接解构成多个变量</p></li></ul><p>​        4.函数的参数</p><p>​            参数，函数再调用的时候指定具体的一个变量的值，语法：</p><pre><code>def 函数名(参数列表):    函数体</code></pre><pre><code>def yue(chat):    print(&quot;拿出手机&quot;)    print(&quot;打开&quot;+chat)yue(&quot;微信&quot;)yue(&quot;默默&quot;)</code></pre><ul><li><p>形参</p><p>​    写在函数声明的位置的变量叫形参,形式上的一个完整,表示这个函数需要xxx</p></li><li><p>实参</p><p>​    在函数调用的时候给函数传递的值,叫实参,实际执行的时候给函数传递的信息,表示给函数xxx</p></li><li><p>传参</p><p>​    给函数传递信息的时候将实际参数交给形式参数的过程称为传参</p><pre><code>def yue(chat):     # chat 形参 print(&quot;拿出⼿机&quot;) print(&quot;打开&quot;+chat) print(&quot;找个漂亮的妹⼦&quot;) print(&quot;约不约&quot;)yue(&quot;陌陌&quot;)     # 实参len(&quot;字符串&quot;)     # &quot;字符串&quot;在这⾥就是实参print(&quot;麻花藤&quot;)     # &quot;麻花藤&quot;就是实参]()</code></pre></li></ul><pre><code>                函数名:命名规则和变量一样    函数的返回值:        return,函数执行完毕,不会执行后面的逻辑            1.如果函数中不写return返回None            2.只写return 返回None            3.return返回值,返回一个值            4.return 值1,值2,... 返回多个值,调用方接收到的是元祖(tuple)        参数:            在函数执行的时候给函数传递的参数            1.形参:                1.位置参数.                2.默认值参数.当调用的时候不给传值使用默认值                3.混合使用.顺序:    1.位置参数, 2.默认值参数            2.实参:                1.位置参数.按照位置给形参赋值                2.关键字参数.按照名称给形参赋值                3.混合参数.先用位置参数,再用关键字参数</code></pre><ul><li><p>例子</p><p>​    编写函数,给函数传递两个参数a,b 比较a, b的大小</p></li></ul><pre><code>def my_max(a,b):    if a &gt; b:        return a    else:        return b#有点麻烦,用一个三元运算符def my_max(a,b):    c = a if a &gt; b else b    #当 a&gt;b 成立返回a,否则返回b    return cl = my_max(11,22)print(l)</code></pre><ul><li><p>关键字参数</p><p>​    </p><pre><code>def yue(chat, address, age): print(&quot;拿出⼿机&quot;) print(&quot;打开&quot;+chat) print(&quot;找个&quot;+address+&quot;附近漂亮的&quot;+str(age)+&quot;岁妹⼦&quot;) print(&quot;约不约&quot;)yue(chat=&quot;微信&quot;, age=18, address=&quot;北京&quot;) # 关键字参数. </code></pre></li><li><p>混合参数</p><p>​    </p><pre><code># 混合参数yue(&quot;微信&quot;, age=18, address=&quot;上海&quot;) # 正确.第⼀个位置赋值给chat, 后⾯的参数开始指定关键字.</code></pre></li><li><p>默认值参数</p><pre><code>def stu_info(name,age,sex=&#39;男&#39;):    print(&quot;录入学生的信息&quot;)    print(name,age,sex)    print(&quot;录入完毕&quot;)stu_info(&quot;张强&quot;,12)</code></pre></li></ul><h2 id="函数的进阶"><a href="#函数的进阶" class="headerlink" title="函数的进阶"></a>函数的进阶</h2><ul><li><p>函数参数–动态传参</p><p>​    一.动态参数分为两种</p><p>​            1.动态接收位置参数</p><pre><code>def func(*args):    print(&quot;我要吃&quot;,args)func(&quot;炸鸡&quot;,&quot;汉堡&quot;)结果:我要吃(&#39;炸鸡&#39;,&#39;汉堡&#39;)        #多个参数传进去,收到的内容是tuple</code></pre><pre><code>def chi( *food, a, b): # 可以传入任意的位置参数    print(&quot;我要吃&quot;, food,a,b)  # 动态参数接收到的是tuple类型的数据chi(&quot;盖浇饭&quot;, &quot;辣条&quot;, a = &quot;面条&quot;,b = &quot;啊啊&quot;)</code></pre><ul><li><p>位置参数&gt; *args &gt; 默认值参数 &gt; **kwargs</p><p>关键字参数一定在位置参数后面</p></li></ul></li></ul><pre><code>def func(a, b, c, *args, d = 5):    print(a, b, c, d, args)func(1,2,3)func(1,2,3,4,5,6,7, d =&quot;马大哈&quot;)</code></pre><p>1.例子</p><pre><code>#　写函数. 给函数传递任意个整数. 返回这些数的和 def he(*n):     sum = 0     for e in n:       sum += e     return sum print(he(5))</code></pre><p>​                2.动态接收关键字参数</p><p>​    *位置参数</p><p>​    **关键字参数</p><pre><code> def func(**food):   # **food动态接收关键字参数     print(food) # 接收到的是字典 func(good_food=&quot;盖浇饭&quot;, bad_food=&quot;辣条&quot;, drink=&quot;冰封&quot;)</code></pre><pre><code> 这个函数可以接收所有的参数(无敌的) def func(*args, **kwargs):     print(args)     print(kwargs) func(1, 2, 5, 6, name=&quot;taibai&quot;,age=18, sex=&quot;不详&quot;)</code></pre><ul><li>动态参数的另一种穿传参方式:</li></ul><pre><code>def fun(*args):    print(args)lst = [1, 4, 7]fun(lst[0], lst[1], lst[2])fun(*lst) # 可以使⽤*把⼀个列表按顺序打散s = &quot;⾂妾做不到&quot;fun(*s) # 字符串也可以打散, (可迭代对象)</code></pre><p>在实参位置给一个序列,列表,可迭代对象前面加个*表示把这个序列按顺序打散</p><p>在形参的位置上的*表示把接收到的参数组合成一个元组</p><p>如果是一个字典,那么也可以打散,不过需要两个**</p><pre><code>def fun(**kwargs):    print(kwargs)dic = &#123;&#39;a&#39;:1, &#39;b&#39;:2&#125;fun(**dic)</code></pre><h3 id="二-命名空间"><a href="#二-命名空间" class="headerlink" title="二.命名空间"></a>二.命名空间</h3><p>​    在Python解释器开始执行之后,就会在内存中开辟一个空间,每当遇到一个变量的时候,就把变量名和值之间的关系记录下来,但是当遇到函数定义的时候,解释器只是把函数名读入内存,表示这个函数存在了,至于函数内部的变量和逻辑,解释器不关心这个,也就是说一开始的时候函数只是加载进来,仅此而已,只有当函数被调用和访问的时候.解释器才会根据函数内部声明的变量来进行开辟变量的内部空间.随着函数执行完毕.这些函数内部变量占用的空间也会随着函数执行完毕而被清空</p><ul><li>在形参上* 聚合,**聚合</li><li>在实参上*打散, **打散</li></ul><p>1.命名空间的分类:</p><p>​    a.内置命名空间–&gt;Python解释内部运行时的变量函数</p><p>​    b.全局命名空间–&gt;我们在py文件中直接声明出来的变量,函数</p><p>​    c.局部命名空间–&gt;在函数内部声明的变量和函数</p><p>​    取值顺序:1.局部命名空间  2. 全局命名空间  3. 内置命名空间</p><h3 id="三-作用域"><a href="#三-作用域" class="headerlink" title="三.作用域"></a>三.作用域</h3><p>​        作用域就是作用范围</p><p>​    1.全局作用域–&gt;内置+全局</p><p>​    2.局部作用域–&gt;局部(在函数内部使用)</p><p>globals() 查看全局作用域中的名字</p><p>locals()  查看当前作用域的名字</p><pre><code>a = 10def func():    a = 40    b = 20    def abc():        print(&quot;哈哈&quot;)    print(a, b)     # 这⾥使⽤的是局部作⽤域    print(globals())     # 打印全局作⽤域中的内容    print(locals())     # 打印局部作⽤域中的内容func()</code></pre><h3 id="四-函数嵌套"><a href="#四-函数嵌套" class="headerlink" title="四.函数嵌套"></a>四.函数嵌套</h3><ol><li><p>只要遇见了()就是函数的调用, 如果没有() 就不是函数的调用</p></li><li><p>函数的执行顺序</p><p>![](C:\Users\付举鹏\Desktop\Python学习截图\屏幕截图 2020-09-27 221218.png)</p><p>函数的嵌套</p><pre><code>a = 1def fun_1():    a = 2    def fun_2():         def fun_3():             nonlocal a             a =  4             print(a)         print(a)         fun_3()         print(a)    print(a)    fun_2()    print(a)print(a)fun_1()print(a)结果:1 2 2 4 4 4 1</code></pre></li></ol><h3 id="五-关键字-global-和-nonlocal"><a href="#五-关键字-global-和-nonlocal" class="headerlink" title="五.关键字 global 和 nonlocal"></a>五.关键字 global 和 nonlocal</h3><p>​    global 表示把全局变量拿到局部来用</p><pre><code>def func():    global a    # a 不再是局部变量. 是全局变量    a = 30  # 把全局中的a重新赋值成30    print(a)func()print(a)</code></pre><p>​    nonlocal  把离他最近的一层的变量拿过来,不会找全局</p><pre><code>a = 10def func1():    def func2():        nonlocal a  # 找局部作用域中 离他最近的那个变量引入进来        a = 20        print(a)    func2()    print(a)func1()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python文件操作</title>
      <link href="/2020/09/20/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/09/20/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li><p>文件操作</p><p>1.初始文件操作</p><p>2.只读(r,rb)</p><p>3.只写(w,wb)</p><p>4.追加(a,ab)</p><p>5.r+读写</p><p>6.w+写读</p><p>7.a+写读(追加读写)</p><p>8.其他操作方法</p><p>9.文件的修改以及另一种打开文件句柄的方式</p></li></ul><p>  一.初始文件操作</p><p>  ​    使用Python来读写文件是非常简单的操作,使用open()函数打开一个文件,获取文件句柄.</p><p>  然后通过文件句柄就可以进行各种操作,根据打开的方式的不同能够执行的操作也有相应的</p><p>  差异</p><p>  ​    打开文件的方式:r,w,a,r+,w+,a+,rb,wb,ab,r+b,w+b,a+b 默认使用的是r(只读)模式</p><p>  二.只读操作(r,rb)</p><pre><code>f = open(&quot;Text.txt&quot;,mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)content = f.read()print(content)f.close()</code></pre><p>  ​    encoding表示编码集，根据文件的实际保存编码进行获取数据，一般是utf-8</p><p>  ​    rb    读出来的数据是bytes类型，在rb模式下，不能选择encoding字符集</p><pre><code>f = open(&quot;Text.txt&quot;,mode=&quot;rb&quot; )content = f.read()print(content)f.close()结果:b&#39;\xe6\xaf\x85\xe5\x93\xa5, \xe5\xa4\xaa\xe7\x99\xbd,wuse\n\xe5\x91\xb5\xe5\x91\xb5\n\xe6\x97\xa5\xe5\xa4\xa9&#39;</code></pre><p>  ​    rb的作用：在读取非文本文件的时候，比如MP3，图像，视频等信息的时候就需要用到rb，</p><p>  因为这种数据是没办法显示出来的</p><ul><li><p>绝对路径和相对路径</p><p>1.绝对路径：从磁盘根目录开始到文件名</p><p>2.相对路径：同一个文件夹下的文件，相对应当前这个程序所在的文件夹而言，如果在用一个文件夹中，则相对路径就是这个文件夹，如果在上一层文件夹，则要../</p></li></ul><p><img src="C:\Users\付举鹏\AppData\Roaming\Typora\typora-user-images\1600568200931.png" alt="1600568200931"></p><ul><li><p>读取文件的方法</p><p>1.read（）将文件的内容全部读取出来，弊端：占内存，如果文件过大，容易导致内存崩溃</p><pre><code>f = open(&quot;../def/哇擦.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)content = f.read()print(content)结果:友谊地久天⻓,爱⼀点,可惜我是⽔瓶座⼀⽣中最爱</code></pre><p>2.read（）读取n个字符，需要注意的是：如果再次读取，那么会在当前位置继续去读而不是从头读，如果使用rb模式，则读取出来的是n个字节</p><pre><code>f = open(&quot;../def/哇擦.txt&quot;, mode=&quot;r&quot; encoding=&quot;utf-8&quot;)content = f.read(3)print(content)结果:友谊地f = open(&quot;../def/哇擦.txt&quot;, mode=&quot;rb&quot;)content = f.read(3)print(content)结果:b&#39;\xe5\x8f\x8b&#39;f = open(&quot;../def/哇擦.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)content = f.read(3)content2 = f.read(3)print(content)print(content2)结果:友谊地久天⻓</code></pre><p>3.readline（）一次读取一行数据，注意：readline（）结尾，每次读取出来的数据都会有一个\n所以，需要我们使用strip（）方法来去掉\n或者 用replace(“ “,””)去掉所有空格</p><pre><code>import oswith open(&quot;老师点名&quot;,mode=&quot;r&quot;,encoding=&quot;utf-8&quot;) as f1:    for line in f1:        print(line.replace(&quot; &quot;,&quot;&quot;).strip())</code></pre><p>4.readlines（）将每一行形成一个元素，放到一个列表中，将所有的内容读取出来，也是容易出现内存崩溃的问题，不推荐使用</p><pre><code>f = open(&quot;../def/哇擦.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)lst = f.readlines()print(lst)for line in lst:     print(line.strip())</code></pre><p>5.循环读取：这种方式是最好的，每次读取一行内容，不会出现内存溢出的问题</p><pre><code>import oswith open(&quot;老师点名&quot;,mode=&quot;r&quot;,encoding=&quot;utf-8&quot;) as f1:    for line in f1:        print(line..strip()</code></pre></li></ul><p>​    二.写模式(w,wb)</p><ul><li><p>写的时候如果没有文件，则会创建文件，如果文件存在，则将原来文件删除，再写如新的内容</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)f.write(&quot;⾦⽑狮王&quot;)f.flush() # 刷新. 养成好习惯f.close()</code></pre><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)f.write(&quot;⾦⽑狮王&quot;)f.read() # not readable 模式是w. 不可以执⾏读操作f.flush()f.close()</code></pre><p>在wb模式下，可以不指定打开文件的编码，但是写文件的时候不行将字符串转换成utf-8的bytes数据</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;wb&quot;)f.write(&quot;⾦⽑狮王&quot;.encode(&quot;utf-8&quot;))f.flush()f.close()</code></pre></li></ul><p>四.追加（a，ab）</p><p>​    再追加的模式下，我们写入的内容会追加在文件的结尾</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;a&quot;, encoding=&quot;utf-8&quot;)f.write(&quot;麻花藤的最爱&quot;)f.flush()f.close()</code></pre><p>五.读写模式（r+，r+b）</p><p>​    对于读写模式，必须是先读，因为默认光标是在开头的，准备读取的，当读完之后在进行写入，使用频率最高就是r+</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)content = f.read()f.write(&quot;麻花藤的最爱&quot;)print(content)f.flush()f.close()结果:正常的读取之后, 写在结尾</code></pre><p>​    r+模式，必须是先读取，然后再写入</p><p>六.写读（w+，w+b）</p><p>​    先将所有的内容清空，然后再写入，最后再读取，但读取的内容是空的，一般不常用</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;w+&quot;, encoding=&quot;utf-8&quot;)f.write(&quot;哈哈&quot;)content = f.read()print(content)f.flush()f.close()</code></pre><p>七.追加读（a+）</p><p>​    a+模式下，不论是先读还是后读，都是读不到数据的</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;a+&quot;, encoding=&quot;utf-8&quot;)f.write(&quot;⻢化腾&quot;)content = f.read()print(content)f.flush()f.close()</code></pre><p>八.其他相关操作</p><p>​    1.seek(n) 光标移动到n位置，注意，移动的单位是byte。一个中文字是3个byte</p><p>​        通常我们使用seek()都是移动到开头或者结尾</p><p>​        移动到开头：seek()</p><p>​        移动到结尾：seek(0,2)    seek的第二个参数表示的是从哪个位置进行偏移，默认是0(表示开头)、1表示当前位置，2表示结尾</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)f.seek(0) # 光标移动到开头            #不管前面你读了几个，后面去写都是再末尾            #再不进行任何操作的时候，在开头写            #如果读取了一些内容，再写，会写到结尾content = f.read() # 读取内容, 此时光标移动到结尾print(content)f.seek(0) # 再次将光标移动到开头f.seek(0, 2) # 将光标移动到结尾content2 = f.read() # 读取内容. 什么都没有print(content2)f.seek(0) # 移动到开头f.write(&quot;张国荣&quot;) # 写⼊信息. 此时光标在9 中⽂3 * 3个 = 9f.flush()f.close()</code></pre><p>​    </p><p>​    2.tell() 使用tell()可以帮我们获取当前光标的位置</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)f.seek(0) # 光标移动到开头content = f.read() # 读取内容, 此时光标移动到结尾print(content)f.seek(0) # 再次将光标移动到开头f.seek(0, 2) # 将光标移动到结尾content2 = f.read() # 读取内容. 什么都没有print(content2)f.seek(0) # 移动到开头f.write(&quot;张国荣&quot;) # 写⼊信息. 此时光标在9 中⽂3 * 3个 = 9print(f.tell()) # 光标位置9f.flush()f.close()</code></pre><p>​    3.truncate() 截断文件</p><pre><code>f = open(&quot;⼩娃娃&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)f.write(&quot;哈哈&quot;) # 写⼊两个字符f.seek(3) # 光标移动到3, 也就是两个字中间f.truncate() # 删掉光标后⾯的所有内容f.close()f = open(&quot;⼩娃娃&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)content = f.read(3) # 读取12个字符f.seek(4)print(f.tell())f.truncate() # 后⾯的所有内容全部都删掉# print(content)f.flush()f.close()</code></pre><p>  <strong>深坑请注意: 在r+模式下. 如果读取了内容. 不论读取内容多少. 光标显⽰的是多少. 再写入 或者操作⽂件的时候都是在结尾进⾏的操作.</strong>   </p><p> 所以如果想做截断操作. 记住了. 要先挪动光标. 挪动到你想要截断的位置. 然后再进⾏截断 关于truncate(n), 如果给出了n. 则从开头开头进⾏截断, 如果不给n, 则从当前位置截断. 后⾯ 的内容将会被删除 </p><p>九.修改文件以及另一种打开文件的方法</p><p>​    文件修改：只能将文件中的内容读取到内存中，将信息修改完毕，然后将源文件删除，将新文件的名字改成老文件的名字</p><pre><code>import oswith open(&quot;文件&quot;,mode=&quot;r&quot;,encoding=&quot;utf-8&quot;) as f1,\        open(&quot;文件_副本&quot;,mode=&quot;w&quot;,encoding=&quot;utf-8&quot;) as  f2:    for line in f1:        s1 = line.replace(&quot;肉&quot;,&quot;菜&quot;)        f2.write(s1)os.remove(&quot;文件&quot;)os.rename(&quot;文件_副本&quot;,&quot;文件&quot;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 文件各种操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/08/31/Python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/08/31/Python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li><p>while循环</p><pre><code>count = 1while count &lt; 8:    print(&quot;....&quot;)while True:    s = input(&quot;start:&quot;)    if s == &quot;t&quot;:        break #结束本次循环    if &#39;a&#39; in s:        print(&quot;输入内容不符合规则&quot;)        continue    #结束当前循环，继续执行下一次循环    print(&quot;ss:&quot;+s)#1+2+3+4...+100?count = 1sum = 0while count &lt;= 100:    sum += count    count +=1print(sum)#输出1-100中的奇数count = 1while count &lt;=100:    if count % 2 !=0:        print(count)    count += 1</code></pre></li><li><p>格式化输出</p><pre><code>name = input(&quot;输入名字：&quot;)age = input(&quot;年龄：&quot;)gender = input(&quot;xingbie:&quot;)print(&quot;%s今年%s，爱好，性bie%s&quot;%(name,age,gender))#%s表示占位符（任何类型） %d ：数字    %%2=%2 表示转义（%默认占位）</code></pre><p> %s就是代表字符串占位符，除此之外，还有%d, 是数字占位符， 如果把上⾯的age后⾯的换成%d，就代表你必须只 能输⼊数字啦 这时对应的数据必须是int类型. 否则程序会报错 使⽤时,需要进⾏类型转换.  </p></li><li><p>基本运算符</p><p>​    1.算数运算符</p><p>​    2.比较运算符     != 和 &lt;&gt; 表示不等于</p><p>​    3.逻辑运算符    and ：并且的意思(两边都为真，结果为真)     or：或者的的意思(两边有一个为真，则为真，全部是假，结果才能是假)    not 非的意思(相反)</p><p>​    #and or not 同时存在时，先算括号，然后not，然后and，最后or</p><pre><code>print(3&gt;4 or 4&lt;3 and 1==1)    Falseprint(1 &lt; 2 and 3 &lt; 4 or 1&gt;2) Trueprint(2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &lt; 1) Trueprint(1 &gt; 2 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 or 9 &lt; 8)    Falseprint(1 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6) Falseprint(not 2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6) Falseprint(1 or 2) 1print(0 or 3) 3         # x or y 如果x==0，那么就是y，否则是xprint(0 and 2)    0        #and 相反 x and 如果x==0 那么就是x，否则就是yprint(1 and 2)     2</code></pre><p>​    4.赋值运算符</p><p>​    5.成员运算符</p><p>​    6.身份运算符</p><p>​    7.位运算符</p></li></ul><p><strong>一.python基本数据类型</strong> </p><p>​        1. int ==&gt;  整数. 主要用来进行数学运算 </p><p>​         2. str ==&gt; 字符串, 可以保存少量数据并进行相应的操作 </p><p>​         3. bool==&gt;判断真假, True, False</p><p>​         4. list==&gt; 存储大量数据.⽤用[ ]表示 </p><p>​         5. tuple=&gt; 元组, 不可以发⽣生改变 用( )表示</p><p>​         6. dict==&gt; 字典, 保存键值对, 一样可以保存⼤大量量数据 </p><p>​         7.set==&gt; 集合, 保存大量数据.  不可以重复. 其实就是不保存value的dict</p><p><strong>二.  整数(int)</strong>    在python3中所有的整数都是int类型. 但在python2中如果数据量比较⼤大. 会使用long类型. 在python3中不存在long类型</p><p>​    <strong>整数可以进行的操作:</strong> </p><p><strong>bit_length()</strong>. 计算整数在内存中占⽤用的二进制码的长度</p><p><strong>三. 布尔值(bool)</strong>    </p><p>取值只有True, False. bool值没有操作</p><p>.     转换问题:         str =&gt; int       int(str)        int =&gt; str       str(int)        int =&gt; bool    bool(int). </p><p> <strong>0是False 非0是True</strong>        </p><p>​        bool=&gt;int      int(bool)   True是1, False是0        str =&gt; bool    bool(str)  </p><p><strong>空</strong></p><p>​    *字符串是False,  不空是True        bool =&gt; str    str(bool)  把bool值转换成相应的”值”** </p><p><strong>四. 字符串(str)</strong>    </p><p>​    把字符连成串. 在python中用’, “, ‘’’, “””引起来的内容被称为字符串.</p><h4 id="五-编码"><a href="#五-编码" class="headerlink" title="五.编码"></a>五.编码</h4><ul><li><p>最早的计算机编码是ASCLL</p><p>1.GBK 每个字符占2个字节,16位</p><p>2.unicode 万国码  usc-2 16位 2个字节    ucs-4 32位 4个字节</p><p>3.UTF-8 每个字符最少占8位,英文占一个1字节,中文占3个字节 ,可变编码长度</p><p>4.UTF-16 每个字符最少占16位</p><ul><li><p>单位转换</p><p>8bit=1byte</p><p>1024byte=1KB</p><p>1024KB=1MB</p><p>1024MB=1GB</p><p>1024GB=1TB</p><p>1024TB=1PB</p><p>1024PB=1EB</p><p>1024EB=1ZB</p><p>1024ZB=1YB</p><p>1024YB=1NB</p></li></ul></li><li><p>基本数据类型(list,tuple)</p><ul><li><p>列表</p><p>1.列表的介绍</p><p>​     列表是python的基础数据类型之⼀ ,其他编程语⾔也有类似的数据类型. 比如JS中的数 组, java中的数组等等. 它是以[ ]括起来, 每个元素⽤’ , ‘隔开⽽且可以存放各种数据类型:  </p><pre><code>lst = [1, &#39;哈哈&#39;, &quot;吼吼&quot;, [1,8,0,&quot;百度&quot;], (&quot;我&quot;,&quot;叫&quot;, &quot;元&quot;, &quot;组&quot;), &quot;abc&quot;, &#123;&quot;我叫&quot;:&quot;dict字典&quot;&#125;,&#123;&quot;我叫集合&quot;,&quot;集合&quot;&#125;]</code></pre><p> 列表相比于字符串. 不仅可以存放不同的数据类型. ⽽且可以存放⼤量的数据. 32位 python可以存放: 536870912个元素, 64位可以存放: 1152921504606846975个元素.⽽且列 表是有序的(按照你保存的顺序),有索引, 可以切⽚⽅便取值. </p><p>2.列表的索引和切片</p><p>​    列表和字符串一样也拥有索引：</p><pre><code>lst = [&quot;麻花藤&quot;, &quot;王剑林&quot;, &quot;⻢芸&quot;, &quot;周鸿医&quot;, &quot;向华强&quot;]print(lst[0]) # 获取第⼀个元素print(lst[1])print(lst[2])lst[3] = &quot;流动强&quot; # 注意. 列表是可以发⽣改变的. 这⾥和字符串不⼀样print(lst) # [&#39;麻花藤&#39;, &#39;王剑林&#39;, &#39;⻢芸&#39;, &#39;流动强&#39;, &#39;向华强&#39;]s0 = &quot;向华强&quot;s0[1] = &quot;美&quot; # TypeError: &#39;str&#39; object does not support item assignment 不允许改变print(s0)</code></pre><p>​    列表的切片</p><pre><code>lst = [&quot;麻花藤&quot;, &quot;王剑林&quot;, &quot;⻢芸&quot;, &quot;周鸿医&quot;, &quot;向华强&quot;]print(lst[0:3]) # [&#39;麻花藤&#39;, &#39;王剑林&#39;, &#39;⻢芸&#39;]print(lst[:3]) # [&#39;麻花藤&#39;, &#39;王剑林&#39;, &#39;⻢芸&#39;]print(lst[1::2]) # [&#39;王剑林&#39;, &#39;周鸿医&#39;] 也有步⻓print(lst[2::-1]) # [&#39;⻢芸&#39;, &#39;王剑林&#39;, &#39;麻花藤&#39;] 也可以倒着取print(lst[-1:-3:-2]) # 倒着带步⻓</code></pre><p>2.列表的增删改查</p><p>​    1.增，注意，list和str是不一样的。lst可以发生改变，所以就在原来的对象上进行了操作</p><pre><code>lst = [&quot;麻花藤&quot;, &quot;林俊杰&quot;, &quot;周润发&quot;, &quot;周芷若&quot;]print(lst)lst.append(&quot;wusir&quot;)print(lst)lst = []while True:     content = input(&quot;请输⼊你要录⼊的员⼯信息, 输⼊Q退出:&quot;)     if content.upper() == &#39;Q&#39;:         break     lst.append(content)print(lst)lst = [&quot;麻花藤&quot;, &quot;张德忠&quot;, &quot;孔德福&quot;]lst.insert(1, &quot;刘德华&quot;) # 在1的位置插⼊刘德华. 原来的元素向后移动⼀位print(lst)# 迭代添加lst = [&quot;王志⽂&quot;, &quot;张⼀⼭&quot;, &quot;苦海⽆涯&quot;]lst.extend([&quot;麻花藤&quot;, &quot;麻花不疼&quot;]) 添加的列表print(lst)</code></pre><p>​    2.删除</p><p>​        pop,remove,clear,del</p><pre><code>lst = [&quot;麻花藤&quot;, &quot;王剑林&quot;, &quot;李嘉诚&quot;, &quot;王富贵&quot;]print(lst)deleted = lst.pop() # 删除最后⼀个,有返回值print(&quot;被删除的&quot;, deleted)print(lst)el = lst.pop(2) # 删除2号元素print(el)print(lst)lst.remove(&quot;麻花藤&quot;) # 删除指定元素print(lst)# lst.remove(&quot;哈哈&quot;) # 删除不存在的元素会报错# # print(lst)lst.clear() # 清空listprint(lst)# 切⽚删除del lst[1:3]print(lst)</code></pre><p>​    3.修改</p><p>​    索引切片修改</p><pre><code># 修改lst = [&quot;太⽩&quot;, &quot;太⿊&quot;, &quot;五⾊&quot;, &quot;银王&quot;, &quot;⽇天&quot;]lst[1] = &quot;太污&quot; # 把1号元素修改成太污print(lst)lst[1:4:3] = [&quot;麻花藤&quot;, &quot;哇靠&quot;] # 切⽚修改也OK. 如果步⻓不是1, 要注意. 元素的个数print(lst)lst[1:4] = [&quot;李嘉诚个⻳⼉⼦&quot;] # 如果切⽚没有步⻓或者步⻓是1. 则不⽤关⼼个数print(lst)</code></pre><p>​    4.查询</p><p>​    列表是一个可迭代对象，可以有for进行循环</p><pre><code>for el in lst: print(el)</code></pre><p>​    5.其他操作</p><pre><code>lst = [&quot;太⽩&quot;, &quot;太⿊&quot;, &quot;五⾊&quot;, &quot;银王&quot;, &quot;⽇天&quot;, &quot;太⽩&quot;]c = lst.count(&quot;太⽩&quot;) # 查询太⽩出现的次数print(c)lst = [1, 11, 22, 2]lst.sort() # 排序. 默认升序print(lst)lst.sort(reverse=True) # 降序print(lst)lst = [&quot;太⽩&quot;, &quot;太⿊&quot;, &quot;五⾊&quot;, &quot;银王&quot;, &quot;⽇天&quot;, &quot;太⽩&quot;]print(lst)lst.reverse() 没有返回值，显示None，对列表反向排序print(lst)l = len(lst) # 列表的⻓度print(l)</code></pre><p>​    6.列表的嵌套</p><pre><code>lst = [1, &quot;太⽩&quot;, &quot;wusir&quot;, [&quot;⻢⻁疼&quot;, [&quot;可⼝可乐&quot;], &quot;王剑林&quot;]]# 找到wusirprint(lst[2])# 找到太⽩和wusirprint(lst[1:3])# 找到太⽩的⽩字print(lst[1][1])# 将wusir拿到. 然后⾸字⺟⼤写. 再扔回去s = lst[2]s = s.capitalize()lst[2] = sprint(lst)# 简写lst[2] = lst[2].capitalize()print(lst)# 把太⽩换成太⿊lst[1] = lst[1].replace(&quot;⽩&quot;, &quot;⿊&quot;)print(lst)# 把⻢⻁疼换成⻢化疼lst[3][0] = lst[3][0].replace(&quot;⻁&quot;, &quot;化&quot;)print(lst[3][0])lst[3][1].append(&quot;雪碧&quot;)print(lst)</code></pre></li></ul></li></ul><ul><li><p>元组和元组的嵌套</p><ul><li><p>元组：俗称不可变的列表，又被称为只读列表，元组也是python的基本数据类型之一，</p><p>​            有小括号括起来，里面可以放任何数据类型的数据，查询也可以，循环也可以，</p><p>​            切片也可以，但就是不能改</p><pre><code>tu = (1, &quot;太⽩&quot;, &quot;李⽩&quot;, &quot;太⿊&quot;, &quot;怎么⿊&quot;)print(tu)print(tu[0])print(tu[2])print(tu[2:5]) # 切⽚之后还是元组# for循环遍历元组for el in tu: print(el)# 尝试修改元组# tu[1] = &quot;⻢⻁疼&quot; # 报错 &#39;tuple&#39; object does not support item assignmenttu = (1, &quot;哈哈&quot;, [], &quot;呵呵&quot;)# tu[2] = [&quot;fdsaf&quot;] # 这么改不⾏tu[2].append(&quot;麻花藤&quot;) # 可以改了. 没报错tu[2].append(&quot;王剑林&quot;)print(tu)</code></pre><ul><li><p>关于不可变，注意：这里元组不可变的意思是：子元素不可变，而子元素内部的子元素是可变的，这取决于子元素是否是可变对象</p></li><li><p>元组中如果只有一个元素，一定要添加一个逗号，否则就不是元组</p><pre><code>tu = (1,)print(type(tu))</code></pre><p> 元组也有count(), index(), len()等⽅法 </p></li></ul><p>1.range</p><p>​    range可以帮我获取一组数据，通过for循环能够获取到这些数据</p><pre><code>for num in range(10): print(num)for num in range(1, 10, 2): print(num)for num in range(10, 1, -2): # 反着来, 和切⽚⼀样 print(num)</code></pre></li></ul></li></ul><ul><li><p>基本数据类型（dict）</p><ul><li><p>字典（dict）是python中唯一的一个映射类型，是以{}括起来的键值对组成。在dict中key是唯一的，在保存的时候，根据key来计算出一个内存地址，然后将key-value保存在这个地址中。这种算法被称为hash算法，所以在dict中key必须是hash的。哈希所谓就是不可变的</p></li><li><p>语法</p><ul><li>{key1：value，key2：value}<ul><li>注意：key必须是可哈希的，value没有要求，可以保存任意类型的数据</li></ul></li></ul><pre><code># 合法dic = &#123;123: 456, True: 999, &quot;id&quot;: 1, &quot;name&quot;: &#39;sylar&#39;, &quot;age&quot;: 18, &quot;stu&quot;: [&#39;帅哥&#39;, &#39;美⼥&#39;], (1, 2, 3): &#39;麻花藤&#39;&#125;print(dic[123])print(dic[True])print(dic[&#39;id&#39;])print(dic[&#39;stu&#39;])print(dic[(1, 2, 3)])# 不合法# dic = &#123;[1, 2, 3]: &#39;周杰伦&#39;&#125; # list是可变的. 不能作为key# dic = &#123;&#123;1: 2&#125;: &quot;哈哈哈&quot;&#125; # dict是可变的. 不能作为keydic = &#123;&#123;1, 2, 3&#125;: &#39;呵呵呵&#39;&#125; # set是可变的, 不能作为key</code></pre><p>dict保存的数据不是按照我们添加进去的顺序保存的,是按照hash表的顺序保存的,而hash表不是连续的,所以不能进行切片工作,只能通过key来获取dict 中的数据</p></li><li><p>字典的增删改查和其他相关操作</p><ul><li>增加</li></ul><pre><code>dic = &#123;&#125;dic[&#39;name&#39;] = &#39;周润发&#39; # 如果dict中没有出现这个key, 就会新增⼀个key-value的组合进dictdic[&#39;age&#39;] = 18print(dic)# 如果dict中没有出现过这个key-value. 可以通过setdefault设置默认值dic.setdefault(&#39;李嘉诚&#39;) # 也可以往⾥⾯设置值.dic.setdefault(&quot;李嘉诚&quot;, &quot;房地产&quot;) # 如果dict中已经存在了. 那么setdefault将不会起作⽤print(dic)</code></pre><ul><li>删除</li></ul><pre><code>ret = dic.pop(&quot;jay&quot;)print(ret)del dic[&quot;jay&quot;]print(dic)# 随机删除.ret = dic.popitem()# 清空字典中的所dic.clear()</code></pre><ul><li>修改</li></ul><pre><code>dic = &#123;&quot;id&quot;: 123, &quot;name&quot;: &#39;sylar&#39;, &quot;age&quot;: 18&#125;dic1 = &#123;&quot;id&quot;: 456, &quot;name&quot;: &quot;麻花藤&quot;, &quot;ok&quot;: &quot;wtf&quot;&#125;dic.update(dic1) # 把dic1中的内容更新到dic中. 如果key重名. 则修改替换. 如果不存在key, 则新增.print(dic)print(dic1)</code></pre><ul><li>查询</li></ul><pre><code>print(dic[&#39;name&#39;])# print(dic[&#39;sylar&#39;]) # 报错print(dic.get(&quot;ok&quot;))print(dic.get(&quot;sylar&quot;)) # Noneprint(dic.get(&quot;sylar&quot;, &quot;⽜B&quot;)) # ⽜B</code></pre><ul><li>其他相关操作</li></ul><pre><code>dic = &#123;&quot;id&quot;: 123, &quot;name&quot;: &#39;sylar&#39;, &quot;age&quot;: 18, &quot;ok&quot;: &quot;科⽐&quot;&#125;print(dic.keys()) # dict_keys([&#39;id&#39;, &#39;name&#39;, &#39;age&#39;, &#39;ok&#39;]) 不⽤管它是什么.当成list来⽤就⾏for key in dic.keys(): print(key)print(dic.values()) # dict_values([123, &#39;sylar&#39;, 18, &#39;科⽐&#39;]) ⼀样. 也当list来⽤for value in dic.values(): print(value)print(dic.items()) # dict_items([(&#39;id&#39;, 123), (&#39;name&#39;, &#39;sylar&#39;), (&#39;age&#39;,18), (&#39;ok&#39;, &#39;科⽐&#39;)]) 这个东⻄也是list. 只不过list中装的是tuplefor key, value in dic.items(): # ?? 这个是解构 print(key, value)    结果 123 456    True 999    id 1    name sylar    age 18    stu [&#39;帅哥&#39;, &#39;美⼥&#39;]    (1, 2, 3) 麻花藤</code></pre></li></ul></li></ul><pre><code># 解构a, b = 1, 2print(a, b)(c, d) = 3, 4print(c, d)e, f = [1, 2, 3] # 解构的时候注意数量必须匹配print(e, f)```- 字典的嵌套```# 字典的嵌套dic1 = &#123; &quot;name&quot;: &quot;汪峰&quot;, &quot;age&quot;: 18, &quot;wife&quot;: &#123; &quot;name&quot;: &#39;章⼦怡&#39;, &quot;age&quot;: 28 &#125;, &quot;children&quot;: [&#39;第⼀个⽑孩⼦&#39;, &#39;第⼆个⽑孩⼦&#39;], &quot;desc&quot;: &#39;峰哥不会告我吧. 没关系. 我想上头条的&#39;&#125;print(dic1.get(&quot;wife&quot;).get(&quot;name&quot;))print(dic1.get(&quot;children&quot;))print(dic1.get(&quot;children&quot;)[1])```</code></pre><ul><li><p>万恶之源-编码</p><ul><li><p>is和==的区别</p><ul><li>id()</li></ul><p>通过id（）我们可以查看到一个变量表示的值内存中的地址</p><pre><code>s = &#39;alex&#39;print(id(s)) # 4326667072s = &quot;alex&quot;print(id(s)) # 4326667072lst = [1, 2, 4]print(id(lst)) # 4326685768lst1 = [1, 2, 4]print(id(lst1)) # 4326684360s1 = &quot;@1 2 &quot;s2 = &quot;@1 2 &quot;print(id(s1))print(id(s2)) # 结果⼀致, 但是在终端中是不⼀致的. 所以在python中,命令⾏代码和py⽂件中的代码运⾏的效果可能是不⼀样的</code></pre><p>小数据池（常量池）把我们使用过的值存储在小数据池中，供其他的变量使用，小数据池给数字和字符串使用，其他数据类型不存在。</p><p>对于数字：-5~256是会被加到效数据池中的，每次使用的都是同一个对象</p><p>对于字符串：</p><p>​    1.如果是纯文字信息和下划线，那么这个对象会被添加到小数据池</p><p>​    2.如果是带有特殊字符的，那么不会添加到小数据池，每次都是新的</p><p>​    3.如果是带有字母*n的情况，’a’*20,在20个单位内是可以 的. 超过20个单位就不会添加 到⼩数据池中 </p></li></ul></li></ul><pre><code>注意(⼀般情况下): 在py⽂件中. 如果你只是单纯的定义⼀个字符串. 那么⼀般情况下都是会 被添加到⼩数据池中的. 我们可以这样认为: 在使⽤字符串的时候, python会帮我们把字符串 进⾏缓存, 在下次使⽤的时候直接指向这个字符串即可. 可以节省很多内存. - 总结: is 比较的是地址 == 比较的是值 </code></pre><ul><li><p>编码的补充</p><ul><li>python2中默认使⽤的是ASCII码. 所以不⽀持中⽂. 如果需要在Python2中更改编码. 需要在⽂件的开始编写: </li></ul><pre><code># -*- encoding:utf-8 -*-</code></pre><ul><li>python3中: 内存中使⽤的是unicode码.  </li></ul></li></ul><ol><li><p>ASCII : 最早的编码. ⾥⾯有英⽂⼤写字⺟, ⼩写字⺟, 数字, ⼀些特殊字符. 没有中⽂, 8个01代码, 8个bit, 1个byte </p></li><li><p>GBK: 中⽂国标码, ⾥⾯包含了ASCII编码和中⽂常⽤编码. 16个bit, 2个byte </p></li><li><p>UNICODE: 万国码, ⾥⾯包含了全世界所有国家⽂字的编码. 32个bit, 4个byte, 包含了 ASCII </p></li><li><p>UTF-8: 可变⻓度的万国码. 是unicode的⼀种实现. 最⼩字符占8位 </p><p>1.英⽂: 8bit 1byte </p><p>2.欧洲⽂字:16bit 2byte </p><p>3.中⽂:24bit 3byte </p></li></ol><ul><li>在python3的内存中. 在程序运⾏阶段. 使⽤的是unicode编码. 因为unicode是万国码. 什么内 容都可以进⾏显⽰. 那么在数据传输和存储的时候由于unicode比较浪费空间和资源. 需要把 unicode转存成UTF-8或者GBK进⾏存储. 怎么转换呢. 在python中可以把⽂字信息进⾏编码. 编码之后的内容就可以进⾏传输了. 编码之后的数据是bytes类型的数据.其实啊. 还是原来的 数据只是经过编码之后表现形式发⽣了改变⽽已. </li></ul><ul><li><p>bytes的表现形式:  </p><pre><code>    1.  英⽂ b&#39;alex&#39; 英⽂的表现形式和字符串没什么两样       2.   中⽂ b&#39;\xe4\xb8\xad&#39; 这是⼀个汉字的UTF-8的bytes表现形式 </code></pre><p> 字符串在传输时转化成bytes=&gt; encode(字符集)来完成 </p><pre><code>s = &quot;alex&quot;print(s.encode(&quot;utf-8&quot;)) # 将字符串编码成UTF-8print(s.encode(&quot;GBK&quot;)) # 将字符串编码成GBK结果:b&#39;alex&#39;b&#39;alex&#39;s = &quot;中&quot;print(s.encode(&quot;UTF-8&quot;)) # 中⽂编码成UTF-8print(s.encode(&quot;GBK&quot;)) # 中⽂编码成GBK结果:b&#39;\xe4\xb8\xad&#39;b&#39;\xd6\xd0&#39;</code></pre><p>英⽂编码之后的结果和源字符串⼀致. 中⽂编码之后的结果根据编码的不同. 编码结果 也不同. 我们能看到. ⼀个中⽂的UTF-8编码是3个字节. ⼀个GBK的中⽂编码是2个字节. 编码之后的类型就是bytes类型. 在⽹络传输和存储的时候我们python是保存和存储的bytes  类型. 那么在对⽅接收的时候. 也是接收的bytes类型的数据. 我们可以使⽤decode()来进⾏解 码操作. 把bytes类型的数据还原回我们熟悉的字符串: </p><pre><code>s = &quot;我叫李嘉诚&quot;print(s.encode(&quot;utf-8&quot;)) #b&#39;\xe6\x88\x91\xe5\x8f\xab\xe6\x9d\x8e\xe5\x98\x89\xe8\xaf\x9a&#39;print(b&#39;\xe6\x88\x91\xe5\x8f\xab\xe6\x9d\x8e\xe5\x98\x89\xe8\xaf\x9a&#39;.decode(&quot;utf-8&quot;)) # 解码</code></pre><ul><li>编码和解码的时候都需要制定编码格式.  </li></ul><pre><code>s = &quot;我是⽂字&quot;bs = s.encode(&quot;GBK&quot;) # 我们这样可以获取到GBK的⽂字# 把GBK转换成UTF-8# ⾸先要把GBK转换成unicode. 也就是需要解码s = bs.decode(&quot;GBK&quot;) # 解码# 然后需要进⾏重新编码成UTF-8bss = s.encode(&quot;UTF-8&quot;) # 重新编码print(bss)</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python基本数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/08/31/Python/"/>
      <url>/2020/08/31/Python/</url>
      
        <content type="html"><![CDATA[<pre><code> 1. 计算机是什么          基本组成:              主板+cpu+内存              cpu: 主频, 核数（16）               内存：大小(8G, 16G, 32G) 型号: DDR3, DDR4, DDR5,  主频(海盗船，玩家国度)              显卡:　显存。型号(N-GTX 1080 TI, A)。位宽 240显卡(512MB) 210 105              硬盘: 西数。希捷。日立，东芝</code></pre><p>​             </p><pre><code>    计算机最底层是 电子电路. 只能识别两个数 0 12. python的简介    解释型语言. 弱类型语言3. 安装4. hello world    print(&quot;你好啊. 我是周润发&quot;)5. 变量（命名规则）    命名规则；        １. 由数字, 字母, 下划线组成        2. 不能数字开头. 更不能是纯数字        3. 不能是关键字        4. 不要太长        5. 不要用中文        6. 区分大小写        7. 要有意义        8. 驼峰和下划线命名     常量:　全部字母大写常量. 约定俗成6. 数据类型     1. int整数. +-*/% //整除, &gt; &lt; &gt;=  &lt;= !=    2. str字符串. 用&#39;,&quot;,&#39;&#39;&#39;,&quot;&quot;&quot; 引起来的都是字符串 +  *      3. bool 布尔值. 只有True和False两个值7. 用户交互(input)    变量=input(&quot;提示语&quot;)  变量是字符串类型, 字符串=&gt; 数字    =&gt; int(str)8. if判断    最基本用法    if 条件判断:        代码块    运行流程. 当条件是真. 执行代码块    if 条件:        代码块1    else:        代码块2    执行流程: 当条件成立. 执行代码块1. 否则, 执行代码块2. 二选一    if 条件1:        代码块1    elif 条件2:        代码块2    .....    else:        代码块n    执行流程:　自行补全</code></pre><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> Python介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/30/hello-world/"/>
      <url>/2020/08/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
